#!/bin/bash

set -u
set -e
set -o pipefail
shopt -s lastpipe

readonly NL=$'\n'
selfdir="$(dirname "$0")"


valid_host_names=(bergenrabbit r2 rhea thip test-br)

declare -i kind_coreos=0
declare -i kind_fedora=0
declare -i kind_ubuntu=0
declare -i kind_debian=0

declare zram_size=
declare -i with_zswap=0
declare -i with_latex=0
declare -i with_transgui=0
declare -i with_common_packages=0
declare -i with_include_rpmfusion=1

declare -i with_docker=0
declare -i with_sudoless_docker=0
declare -i with_docker_development_net=0
declare -i with_http_proxy=0
declare -i custom_user_watches_count=0

declare bergenrabbit_backup_time=

declare ssh_login_user=
declare machine_host=

# These 2 are deduced automatically
declare primary_user=

declare extra_system_users=()

declare -a explicit_ipv6=()

# Replace lables/uids with real devices in fstab/grub for security
# when allowing untrusted VM to access the whole disk.
declare -i with_disabled_disk_uuid=0

readonly dev_docker_network_prefix="192.168.96"
readonly dev_vz_network_prefix="192.168.97"

readonly gen_self_dir="/run/tliset"

bergenrabbit_dns="www.bergenrabbit.net bergenrabbit.net"
bergenrabbit_dns="${bergenrabbit_dns} www.bergenrabbit.no bergenrabbit.no"
bergenrabbit_dns="${bergenrabbit_dns} www.hippyru.net hippyru.net lib.hippyru.net"
bergenrabbit_dns="${bergenrabbit_dns} www.hippy.ru hippy.ru"
bergenrabbit_dns="${bergenrabbit_dns} www.lubava.info lubava.info"

dserver_eth_wan=enp2s0
dserver_eth_lan=enp4s0

dserver_bridge=macvlan0

mac_kino=52:54:00:54:6e:ef
mac_macbook_air=8c:29:37:e8:0e:e2
mac_tablet=34:23:ba:a4:0f:85

ip_kino=192.168.2.9
ip_drouter=192.168.2.8
ip_tablet=192.168.2.20
ip_macbook_air=192.168.2.21

dserver_port_forwards=(
    "tcp:9092:$ip_kino"
    "tcp:51413:$ip_kino"
    "udp:51413:$ip_kino"
    "tcp:25565:$ip_macbook_air"
    "udp:25565:$ip_macbook_air"
)

hippyru_www_pubkey="ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIIeBgbo19/jj/VDoX3nOybsmrbN95lIBeQYQv+FAOs/z"
media_pubkey="ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAILTrJnFcAg4qiYW8o8E0ieXc+hhnxc7ozAXlUAz1JHT6"
dzetacon_pubkey="ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIBGPGP6D7o3E3cl3gwx8Wa3XTAWOWeNAvcj2ZKY/OhbT"

readonly ssh_kino_wrap="/run/tliset/ssh_kino_wrap"
readonly kino_password_file="/var/lib/tliset/kino_password"


get_host_options() {
    case "$NAME" in
	bergenrabbit )
	    ssh_login_user=core
	    with_docker=1
	    zram_size=512M
	    ;;
 	r2 )
	    bergenrabbit_backup_time=03:00:02
	    explicit_ipv6=(2001:41d0:e:696::1/64 2001:41d0:e:6ff:ff:ff:ff:ff)
	    ssh_login_user=core
	    with_docker=1
	    zram_size=512M
	    ;;
 	rhea )
	    with_common_packages=1
	    #with_docker=1
	    with_latex=1
	    #zram_size=8G
	    with_zswap=1

	    # disable until user namespaces works
	    #with_sudoless_docker=0
	    custom_user_watches_count="$((768*1025))"
	    ;;
	thip )
	    ssh_login_user=core
	    with_docker=1
	    with_docker_development_net=1
	    ;;
	test-br )
	    ssh_login_user=core
	    machine_host=thip
	    ;;
	* )
	    err "unknown '$NAME'"
	    ;;
    esac
}

err() {
    printf '%s:%d:%s: %s\n' "${BASH_SOURCE[0]}" "${BASH_LINENO[0]}" "${FUNCNAME[0]}" "$*" >&2
    exit 1
}

usage_err() {
    echo "$0: $@" 1>&2
    echo "Try $0 -h for usage" 1>&2
    exit 1
}

getopts_err() {
    local name=$1 optarg=$2 msg
    case "$name" in
	: ) msg="$-optarg requires an argument" ;;
	\? ) msg="unknown option -$optarg" ;;
	* ) msg="-$name is listed in getopts arguments but not processed" ;;
    esac
    if let "${#FUNCNAME[@]} <= 2"; then
	usage_err "$msg"
    else
	err "${FUNCNAME[1]} - $msg"
    fi
}

log_indent_level=0

log() {
    local indent='' i
    for ((i=0; i<log_indent_level; i+=1)); do
	indent+='  '
    done
    printf '%s%s\n' "$indent" "$*" 1>&2
}

cmd_log() {
    log "$*"
    "$@"
}

inc_log_level() {
    let log_indent_level+=1 || true
}

dec_log_level() {
    [[ $log_indent_level -ge 1 ]] || err "dec_log_level without inc_log_level"
    let log_indent_level-=1 || true
}

pl(){
    lines="${lines} $*${NL}"
}

determine_os() {
    local os_kind=
    if [[ -f /etc/os-release ]]; then
        local line
        {
            while IFS='' read -r line; do
                if [[ $line =~ ^ID=(.*)$ ]]; then
                    os_kind="${BASH_REMATCH[1]}"
                    break;
                fi
            done
        } < /etc/os-release
    fi

    case "${os_kind,,}" in
	coreos | "") kind_coreos=1 ;;
	debian ) kind_debian=1 ;;
	fedora ) kind_fedora=1 ;;
	ubuntu ) kind_ubuntu=1 ;;
	* ) err "Do not know how to determine OS, os_kind='$os_kind'" ;;
    esac
}

under_qubes() {
    if [[ ! -v under_qubes_flag ]]; then
	if [[ -d /etc/qubes ]]; then
	    declare -r -g under_qubes_flag=1
	else
	    declare -r -g under_qubes_flag=0
	fi
    fi
    let under_qubes_flag && return 0
    return 1
}

is_valid_host_name() {
    local name="$1" i
    for i in "${valid_host_names[@]}"; do
	if [[ "$i" == "$name" ]]; then
	    return 0
	fi
    done
    return 1;
}

ensure_dir() {
    local mode group user OPTIND opt dir
    mode=
    group=
    user=

    while getopts :g:m:u: opt; do
    case "$opt" in
    g ) group="$OPTARG";;
    m ) mode="$OPTARG";;
    u ) user="$OPTARG";;
    * ) err "bad ensure_dir usage";;
    esac
    done
    shift $(($OPTIND - 1))

    if test -z "${mode}"; then
	mode=0755
    fi
    if test -z "${user}"; then
	user=root
    fi
    if test -z "${group}"; then
	group="${user}"
    fi

    if test $# -eq 0; then
	return
    fi

    local dir
    for dir in "$@"; do
	test -n "${dir}" || err "directory cannot be empty"
	test "x${dir}" = "x${dir%/}" || err "directory must not end with slash - ${dir}"
	test "x${dir}" != "x${dir#/}" || err "directory must be an absolute path - ${dir}"
	if test ! -d "${dir}"; then
	    test ! -e "${dir}" -a ! -h "${dir}"  || err "${dir} exists and is not a directory"
	    cmd_log mkdir -m "${mode}" "${dir}"
	else
	    test ! -h "${dir}" || \
		err "$path exists and is a symbilic link, not a directory - ${dir}"
	fi
	local s
	s="$(find "${dir}" -maxdepth 0 -perm "${mode}" -user "${user}" -group "${group}")"
	if test -z "${s}"; then
	    cmd_log chmod "=${mode}" "${dir}"
	    cmd_log chown "${user}:${group}" "${dir}"
	fi
	note_path "${dir}"
    done
}

ensure_symlink() {
    local target path
    target="$1"
    path="$2"
    while :; do
	if test -h "${path}"; then
	    local current_target
	    current_target="$(readlink "${path}")"
	    if test "x${current_target}" = "x${target}"; then
		break
	    fi
	elif test -d "${path}" ]]; then
	    cmd_log rmdir "${path}" || \
		err "remove symbolic link ${path} manually and run again"
	fi
	cmd_log ln -sfT "${target}" "${path}"
	break
    done
    note_path "${path}"
}

file_update=
file_update_count=0

write_file() {

    local user group mode OPTIND opt
    user=
    group=
    mode=
    while getopts :g:m:u: opt; do
	case "$opt" in
	g ) group="$OPTARG";;
	m ) mode="$OPTARG";;
	u ) user="$OPTARG";;
	* ) err "bad write_file usage";;
	esac
    done

    shift $((${OPTIND} - 1))
    test $# -eq 2 || err "write_file requires path and body arguments when $# argument was given"

    local path body
    path="$1"
    body="$2"
    if test -z "${user}"; then
	user=root
    fi
    if test -z "${group}"; then
	group="${user}"
    fi
    if test -z "${mode}"; then
	mode=0644
    fi

    local wanted_umask need_chmod
    need_chmod=
    case "${mode}" in
    0644 ) wanted_umask=022 ;;
    0640 ) wanted_umask=027 ;;
    0600 ) wanted_umask=077 ;;
    0660 ) wanted_umask=007 ;;
    0755 ) wanted_umask=022 need_chmod=1 ;;
    * ) err "unsupported mode - ${mode}" ;;
    esac

    local do_update
    do_update=1
    while :; do
	if test ! -f "${path}" -o -h "${path}"; then
	    log "creating new ${path}"
	    break;
	fi
	local s
	s="$(find "$path" -maxdepth 0 -perm "$mode" -user "$user" -group "$group" -printf 1)"
	if test -z "${s}"; then
	    log "updating ${path} - permission changes"
	    break;
	fi

	if printf %s "${body}" | cmp -s "${path}" -; then
	    # Permissions and text matches
	    do_update=
	    break
	fi

	log "updating ${path} - content changes"
	break
    done

    if test -z "${do_update}"; then
	file_update=
    else
	# Use temporary to ensure atomic operation on filesystem
	local tmp
	tmp="${path}.tmp"
	if test -f "${tmp}"; then
	    rm "${tmp}"
	fi

	umask "${wanted_umask}"
	printf %s "${body}" > "${tmp}"
	if test -n "${need_chmod}"; then
	    chmod "${mode}" "${tmp}"
	fi
	chown "${user}:${group}" "${tmp}"
	mv -fT "${tmp}" "${path}"

	file_update=1
	: $((file_update_count+=1))
    fi
    note_path "${path}"
}

read_tliset_name() {
    R=''
    local path=/etc/tliset.name name
    if under_qubes; then
	path="/usr/local$path"
    fi
    [[ -s "$path" ]] || \
	err "$path does not exist or empty. Initilize it with a valid name and try again."
    IFS='' read -r name < "$path"
    local name_pattern='^[a-z0-9]+$'
    [[ $name =~ $name_pattern ]] || \
	err "$path content does not match $name_pattern - '$name'"
    R="$name"
}

add_dns_record_a() {
    local host ipv4
    host="$1"
    ipv4="$2"
    escape_for_shell "--host-record=${host},${ipv4}"
    extra_dnsmasq_eargs="${extra_dnsmasq_eargs} ${R}"
}

add_dns_interface_name() {
    local host interface
    host="$1"
    interface="$2"
    escape_for_shell "--interface-name=${host},${interface}"
    extra_dnsmasq_eargs="${extra_dnsmasq_eargs} ${R}"
}

fixup_transgui() {
    local path=/usr/share/applications/transgui.desktop
    local line='MimeType=application/x-bittorrent;x-scheme-handler/magnet;'
    if ! grep -q "^$line\$" "$path" ; then
	log "fixing $path"
	local data
	data="$(grep -v '^MimeType=' ${path})"
	printf '%s\n%s\n' "$data" "$line" > "${path}.tmp"
	chmod 644 "${path}.tmp"
	mv "${path}.tmp" "${path}"
    fi
}

begin_tliset() {
    paths_file=/var/lib/tliset/paths.txt
    can_note_paths=
    readonly paths_file
    ensure_dir /var/lib/tliset
    exec 9>>"${paths_file}.new"
    can_note_paths=1
    note_path /var/lib/tliset
}

end_tliset() {
    exec 9>&-
    local sorted
    sort "${paths_file}.new" > "${paths_file}.tmp"
    mv "${paths_file}.tmp" "${paths_file}.new"

    # Duplicates happens when tliset runs again after a failure
    uniq "${paths_file}.new" > "${paths_file}.tmp"
    mv "${paths_file}.tmp" "${paths_file}.new"

    if test -f "${paths_file}"; then
	comm -23 "${paths_file}" "${paths_file}.new" > "${paths_file}.unknown"
	filter_existing_paths < "${paths_file}.unknown" > "${paths_file}.tmp"
	mv "${paths_file}.tmp" "${paths_file}.unknown"
	if test -s "${paths_file}.unknown"; then
	    log "No longer generated files from the previous runs:" \
		"${NL}$(cat "${paths_file}.unknown")"
	fi
	sort "${paths_file}.new" "${paths_file}.unknown" > "${paths_file}.tmp"
	mv "${paths_file}.tmp" "${paths_file}.new"
    fi

    mv "${paths_file}.new" "${paths_file}"
}

filter_existing_paths() {
    local line
    while IFS= read -r line; do
	if test -e "${line}" -o -h "${line}"; then
	    printf '%s\n' "${line}"
	fi
    done
}

note_path() {
    local path
    path="$1"
    if test -n "${can_note_paths}"; then
	printf '%s\n' "${path}" 1>&9
    fi
}

setup_packages() {
    let kind_fedora || let kind_ubuntu || return 0

    log "Checking packages"
    inc_log_level
    let kind_fedora && setup_fedora_packages
    let kind_ubuntu && setup_ubuntu_packages
    dec_log_level
    return 0
}


setup_fedora_packages() {
    if let with_common_packages && let with_include_rpmfusion; then
	local rpmfusion_kinds=(
	    free
	    nonfree
	)
	local i rpmfusion_repos=()
	for i in "${rpmfusion_kinds[@]}"; do
	    rpmfusion_repos+=("rpmfusion-$i-release")
	done

	if ! rpm -q --quiet "${rpmfusion_repos[@]}" ; then
	    log "Installing rpmfusion"
	    local urls=()
	    for i in "${rpmfusion_kinds[@]}"; do
		urls+=("http://download1.rpmfusion.org/$i/fedora/rpmfusion-$i-release-$fedora_release.noarch.rpm")
	    done
	    dnf install -y --nogpgcheck "${urls[@]}" || true
	fi
    fi
    local list=()
    if let with_common_packages; then
	list+=(
	    tmux
	    git lsyncd
	    quilt mercurial subversion
	    livecd-tools
	    autoconf automake gcc-c++ kernel-devel
	    geany geany-plugins-spellcheck
	    tigervnc
	    pcp-system-tools strace
	    xclip xorg-x11-apps
	    xpra
	    xorg-x11-server-Xephyr
	    openssh-askpass

	    # filesystems
	    udftools inotify-tools fdupes fslint mtools

	    # encryption and backup
	    apg duplicity perl-Digest-Bcrypt lzip

	    # Recovery tools
	    ddrescue foremost scalpel testdisk

	    # Graphs
	    graphviz graphviz-doc

	    # PDF tools
	    pdfmerge poppler-utils

	    # Media
	    gimp inkscape gthumb
	    scribus
	    evince evince-djvu pdf2djvu
	    linux-libertine-biolinum-fonts linux-libertine-fonts
	    gstreamer1-plugins-good-extras

	    # Languages
	    hunspell-ru hunspell-nb
	)

	if let with_include_rpmfusion; then
	    list+=(
		# Archives
		unrar libunrar

		# Media
		vlc
		kdenlive
		ffmpeg
		gstreamer1-libav
		gstreamer1-plugins-bad-free
		gstreamer1-plugins-bad-free-extras
		gstreamer1-plugins-bad-freeworld
		gstreamer1-plugins-ugly
	    )
	fi

	list+=(
	    # hardware management
	    util-linux lm_sensors
	)


	list+=(
	    gnome-tweaks
	    gnome-terminal-nautilus
	    gnome-shell-extension-alternate-tab
	)
    fi

    let with_latex && list+=(
	    texlive
	    texlive-babel-norsk
	    texlive-hyphen-norwegian
	    texlive-babel-russian
	    texlive-collection-langcyrillic
	)
    let with_transgui && list+=(transgui openssl-devel)

    list+=(gcc kernel-devel)

    if let with_docker; then
	list+=(
	    docker
	)
    fi

    if test rhea = "${NAME}"; then
	list+=(libguestfs-tools)
    fi

    for i in "${list[@]}"; do
	rpm -q --quiet "$i" || echo "Missed: $i"
    done

    if ! rpm -q --quiet "${list[@]}" ; then
	log "Installing missing packages"
	dnf install -y "${list[@]}"
    fi

    local remove_list=()

    if let with_transgui; then
	remove_list+=(transmission-gtk transmission-remote-gtk)
    fi
    if let ${#remove_list[@]}; then
	local status=0
	rpm -q --quiet "${remove_list[@]}" || status=$?
	if let "status < ${#remove_list[@]}"; then
	    cmd_log dnf remove -y "${remove_list[@]}"
	fi
	fixup_transgui
    fi

    write_file /etc/tmux.conf "new-session${NL}"
}

setup_ubuntu_packages() {
    local -a install_list=() remove_list=()
    install_list+=(
	build-essential make-doc gcc g++ pkgconf
	git git-man liberror-perl
	emacs24 emacs24-el xterm xfonts-base
	xtightvncviewer xclip
	lsyncd apg apt-file libdigest-bcrypt-perl duplicity
    )

    if let with_common_packages; then
	install_list+=(
	    dstat
	    libreoffice
	    gvfs-bin
	    libglib2.0-dev
	    libgnome-keyring-dev
	    ffmpeg
	    firejail
	    xpra
	    xephyr
	)
    fi

    let with_transgui && install_list+=(transgui)
    remove_list+=(transmission-common)

    if let with_latex; then
	install_list+=(
	    texlive
	    texlive-lang-cyrillic
	    texlive-lang-european
	)
    fi

    remove_list+=(
	resolvconf
    )

    local -A package_status_map=()

    local -a apt_action_list=()
    fill_apt_action_list install "${install_list[@]:+${install_list[@]}}"
    if [[ ${#apt_action_list[@]} -ne 0 ]]; then
	log "Installing missing packages"
	DEBIAN_FRONTEND=noninteractive cmd_log apt-get install -y "${apt_action_list[@]}"
    fi

    local -a apt_action_list=()
    fill_apt_action_list uninstall "${remove_list[@]:+${remove_list[@]}}"
    if [[ ${#apt_action_list[@]} -ne 0 ]]; then
	log "Purging unnecessary packages ${remove_list[*]}"
	DEBIAN_FRONTEND=noninteractive apt-get purge -y "${apt_action_list[@]}"
    fi
}

fill_apt_action_list() {
    local action="$1"
    shift
    [[ $# -ne 0 ]] || return 0

    # Complication: for unknown packages dpkg-query reports an error,
    # so parse both stdout and stderr.
    local status_package_re='^#stdout ([^ ]+)  ([^ ]+)$'
    local unknown_package_message_re='^dpkg-query: no packages found matching ([^ ]+)$'
    local output
    output="$(dpkg-query -W --showformat '#stdout ${db:Status-Abbrev} ${Package}\n' "$@"  2>&1 || :)"
    if [[ $output ]]; then
	local -a lines
	mapfile -t lines <<< "$output"
	local line
	for line in "${lines[@]}"; do
	    if [[ $line =~ $unknown_package_message_re ]]; then
		local package="${BASH_REMATCH[1]}"
		local status="unknown"
	    elif [[ $line =~ $status_package_re ]]; then
		local status="${BASH_REMATCH[1]}"
		local package="${BASH_REMATCH[2]}"
		case $status in
		    ii ) status=installed ;;
		    un ) status=uninstalled ;;
		    * ) err "unexpected dpkg-query status '$status': $line" ;;
		esac
		package_status_map[$package]="$status"
	    else
		err "unexpected dpkg-query output: $line"
	    fi
	    if [[ $action == install ]]; then
		if [[ $status == installed ]]; then
		    continue
		fi
	    elif [[ $action == uninstall ]]; then
		# purge both installed packages and packages with config-files
		if [[ $status != installed && $status != config-files ]]; then
		    continue
		fi
	    else
		err "bad action: $action"
	    fi
	    apt_action_list+=("$package")
	done
    fi
}

# Set R to concatenation of arguments with spaces escaped if necessary.
escape_for_shell() {
    R=
    local arg
    for arg in "$@"; do
        case "${arg}" in
        "" | *[!A-Z0-9a-z_./-]* )
            local escaped before_quote
            escaped=
            while : ; do
                before_quote="${arg%%\'*}"
                if test "x${arg}" = "x${before_quote}"; then
                    break
                fi
                escaped="${escaped}${before_quote}'\\''"
                arg="${arg#*\'}"
            done
            arg="'$escaped$arg'"
            ;;
        esac
        R="${R}${R:+ }${arg}"
    done
}

earg() {
    escape_for_shell "$@"
    eargs="${eargs}${eargs:+ }$R"
}

start_generator_write() {
    multi_user_wants=()
    sockets_wants=()
    basic_target_wants=()
    systemd_unit_update=
}

print_wants_list() {
    local target
    target="$1"
    shift
    test $# -ne 0 || return 0
    local i wants_body
    wants_body="[Unit]${NL}"
    for i in "$@"; do
	wants_body="${wants_body}Wants=${i}${NL}"
    done
    p_systemd_drop_in "${target}" "${wants_body}"
}

finish_generator_write() {
    print_wants_list multi-user.target "${multi_user_wants[@]:+${multi_user_wants[@]}}"
    print_wants_list sockets.target "${socket_wants[@]:+${socket_wants[@]}}"
    print_wants_list basic.target "${basic_target_wants[@]:+${basic_target_wants[@]}}"

    if test -n "${systemd_unit_update}"; then
	cmd_log systemctl daemon-reload
    fi
}

# The first argument is <kind>:<subpath> where kind specifies
# directory kind and subpath is a file path. The second argument is
# text that should be written into the file at that path. Option -x
# indicattes that file must be executable.
p_file() {
    local executable
    executable=
    case "$1" in
    -x ) shift; executable=1 ;;
    esac
    local file_kind_and_path body
    file_kind_and_path="$1"
    body="$2"
    local path
    convert_kind_path "${file_kind_and_path}"
    path="${R}"

    set --
    if test -n "${executable}"; then
	set -- "$@" -m 0755
    fi
    write_file "$@" "${path}" "${body}"
    if test -n "${file_update}"; then
	case "${file_kind_and_path}" in
	service:* ) systemd_unit_update=1 ;;
	esac
    fi
}

p_dir() {
    local dir
    dir="$1"
    convert_kind_path "${dir}"
    dir="${R}"
    ensure_dir "${dir}"
}

p_ensure_no_file() {
    local file
    file="$1"
    convert_kind_path "${file}"
    file="${R}"
    if test -f "${file}"; then
	cmd_log rm -f "${file}"
    fi
}

p_ensure_no_dir() {
    local dir
    dir="$1"
    convert_kind_path "${dir}"
    dir="${R}"
    if test -d "${dir}"; then
	cmd_log rmdir "${file}"
    fi
}

p_symlink() {
    local target path
    target="$1"
    path="$2"
    convert_kind_path "${path}"
    path="${R}"
    ensure_symlink "${target}" "${path}"
}

p_systemd_drop_in() {
    local unit_name drop_in
    unit_name="$1"
    drop_in_text="$2"

    p_dir "service:${unit_name}.d"
    p_file "service:${unit_name}.d/tliset.conf" "${drop_in_text}"
}

convert_kind_path() {
    local file_kind_and_path file_kind file_path
    file_kind_and_path="$1"
    file_kind="${file_kind_and_path%%:*}:"
    file_path="${file_kind_and_path#*:}"
    if test "x${file_path}" = "x${file_kind_and_path}"; then
	err "the argument must start with <kind>: prefix - ${file_kind_and_path}"
    fi
    local dir
    case "$file_kind" in
    service: ) dir='/etc/systemd/system' ;;
    net: ) dir='/etc/systemd/network' ;;
    scripts: ) dir="/var/lib/tliset" ;;
    sysctl: ) dir="/etc/sysctl.d" ;;
    nspawn: )
	dir='/etc/systemd/nspawn'
	;;
    * ) err "Unknown file kind - ${file_kind_and_path}" ;;
    esac
    ensure_dir "${dir}"

    if test -z "${file_path}"; then
	R="$dir"
	return 0
    fi
    case "${file_path}" in
	/* ) err "the path part must be a relative path: ${file_kind_and_path}" ;;
    esac
    R="${dir}/${file_path}"
}

p_mask_service() {
    p_symlink /dev/null "service:$1"
}

setup_kernel_parameters() {
    if let with_zswap; then
	local unit
	unit=tliset-zswap.service
	p_file "service:${unit}" '
[Service]
Type=oneshot
ExecStart=/bin/sh -c "printf 1 > /sys/module/zswap/parameters/enabled"
ExecStop=/bin/sh -c "printf 0 > /sys/module/zswap/parameters/enabled"
RemainAfterExit=yes
'
	basic_target_wants+=("${unit}")
    fi
    setup_zram

    local sysctl
    sysctl=""
    if let custom_user_watches_count; then
	sysctl+="fs/inotify/max_user_watches=${custom_user_watches_count}${NL}"
    fi
    if test -n "${sysctl}"; then
	p_file sysctl:50-tliset.conf "${sysctl}"
    else
	p_ensure_no_file sysctl:50-tliset.conf
    fi
}

setup_zram() {
    [[ $zram_size ]] || return 0

    log "Checking zram"

    p_file -x scripts:zram-enable.sh '
#!/bin/sh
set -e -u

SWAP_SIZE='"$zram_size"'

num_cpus=$(grep -c processor /proc/cpuinfo)
if test 0 -eq "${num_cpus}"; then
    num_cpus=1
fi

rm -f /run/tliset-zram-device
device="$(zramctl --find --size "${SWAP_SIZE}" -t "${num_cpus}")"
printf "%s\\n" "${device}" > /run/tliset-zram-device

/sbin/mkswap "${device}"
/sbin/swapon -p 100 "${device}"
'

    p_file scripts:zram-disable.sh "$(cat <<'EOF'
#!/bin/sh
set -e -u

device=
test -f /run/tliset-zram-device || exit 0
read -r device < /run/tliset-zram-device || :
test -n "${device}" || exit 0
if grep -q "^${device}\\s" /proc/swaps; then
    /sbin/swapoff "${device}"
fi
zramctl --reset "${device}"
rm /run/tliset-zram-device
EOF
)"

    p_file service:tliset-zram.service "\
[Unit]
Description=Service enabling RAM compression using zRam

[Install]
WantedBy=multi-user.target

[Service]
Type=oneshot
ExecStart=/sbin/modprobe zram num_devices=1
ExecStart=/bin/sh /var/lib/tliset/zram-enable.sh
ExecStop=/bin/sh /var/lib/tliset/zram-disable.sh
RemainAfterExit=yes
"
    multi_user_wants+=(tliset-zram.service)

}

setup_network() {
    log "Checking network"
    inc_log_level

    if [[ ${#explicit_ipv6[@]} -ne 0 ]]; then
	let kind_coreos || err "unsupported configuration"
	local ipv6_address="${explicit_ipv6[0]}"
	local ipv6_gateway="${explicit_ipv6[1]}"
	p_file net:zz-default.network "\
[Network]
DHCP=ipv4

Address=$ipv6_address
Gateway=$ipv6_gateway

[DHCP]
UseMTU=true
UseDomains=true
"
    fi

    if [[ ${NAME} == rhea ]]; then
	p_file "net:40-nspawn1.network" "\
[Match]
Name=*-nspawn1

[Network]
# Default to using a /24 prefix, giving up to 253 addresses per virtual network.
Address=${dev_vz_network_prefix}.1/24
LinkLocalAddressing=yes
#DHCPServer=yes
IPMasquerade=yes
LLDP=yes
EmitLLDP=customer-bridge
"
    fi

    dec_log_level
}

ensure_root_ssh_key() {
    local prefix=$1
    local file=/root/.ssh/$prefix-ed25519
    if [[ ! -s "$file" ]]; then
	cmd_log mkdir -p -m 0700 /root/.ssh
	cmd_log ssh-keygen -t ed25519 -N '' -f "$file"
    fi
    ssh_key_file="$file"
}

setup_bergenrabbit_backup() {
    [[ $bergenrabbit_backup_time ]] || return 0

    local ssh_key_file=
    ensure_root_ssh_key bergenrabbit-www-backup

    if [[ $bergenrabbit_backup_time == manual ]]; then
	return 0
    fi

    [[ $bergenrabbit_backup_time =~ ^[0-2][0-9]:[0-5][0-9]:[0-5][0-9]$ ]] || \
	err "Invalid backup time spec in bergenrabbit_backup_time - '${bergenrabbit_backup_time}'"

    p_file service:tliset-bergenrabbit-backup.timer "\
[Unit]
After=network-online.target
Wants=network-online.target

[Timer]
Persistent=true
OnCalendar=${bergenrabbit_backup_time}
"
    p_file service:tliset-bergenrabbit-backup.service "\
[Unit]
After=network-online.target
Wants=network-online.target

[Service]
ExecStart=/bin/bash /var/lib/tliset/bergenrabbit-backup.bash
StandardError=journal
StandardOutput=journal
Type=oneshot
"
    multi_user_wants+=("tliset-bergenrabbit-backup.timer")

    # Script source with condition code
    local s
    s='#!/usr/bin/bash
set -e -u -o pipefail

# Number of days to keep old backups in the changed dir
max_keep_changed_days=90

'
    # On fedora change SELinux context for rsync so it is treated as
    # a binary, not a service. As an update can reset it, do it each
    # time we are about to run it.
    if let kind_fedora; then
	s+='
se_context=$(stat -c %C /usr/bin/rsync)
if [[ $se_context =~ ^[^:]*:[^:]*:([^:]*):[^:]*$ ]]; then
    if [[ ${BASH_REMATCH[1]} != bin_t ]]; then
        echo "Changing SE context for /usr/bin/rsync from ${BASH_REMATCH[1]} to bin_t" 1>&2
        chcon -t bin_t /usr/bin/rsync
    fi
fi
'
    fi
    s+='

readonly backup_root="/area/backup"

remove_list=()

backup_from_host() {
    local pod_name="$1" host_name="$2"
    local data="$backup_root/$pod_name"
    local changes="$backup_root/changes/$pod_name"
    local partial="$backup_root/rsync-partial/$pod_name"
    local dir
    for dir in "$data" "$changes" "$partial"; do
        if [[ ! -d "$dir" ]]; then
            mkdir -p "$dir"
        fi
    done

    local -a ssh_cmd=(
        ssh -l br-backup -i ~/.ssh/bergenrabbit-www-backup-ed25519
        -o Ciphers=aes128-gcm@openssh.com
        -o StrictHostKeyChecking=no
    )

    local -a rsync_args=(
        -rlpt
        --no-owner --no-group --omit-dir-times --omit-link-times
        --partial-dir="$partial" --delete-after
        --info=NAME
        --rsh="${ssh_cmd[*]}"
    )

    local too_old_backup="$changes/$(date --date="-20 days" +%Y-%m-%d)"
    rm -rf "$too_old_backup"
    local changed_files
    changed_files="$changes/$(date +%Y-%m-%d)"
    mkdir -p "${changed_files}.srv" "${changed_files}.opt"

    echo "Backing up $pod_name" >&2
    local ok=1
    rsync "${rsync_args[@]}" --backup --backup-dir="${changed_files}.srv" \
        "rsync://$host_name/srv/" "$data/srv/" || ok=
    rsync "${rsync_args[@]}" --backup --backup-dir="${changed_files}.opt" \
        "rsync://$host_name/opt/" "$data/opt/" || ok=
    if [[ $ok ]]; then
	local i cur_time
	cur_time="$(date +%s)"
	for i in "$changes"/20[0-9][0-9]-[0-9][0-9]-[0-9][0-9].*; do
	    local file_name
	    file_name="${i##*/}"
	    dir_time="$(date --date="${file_name%%.*}" +%s)"
	    if test "$((cur_time-dir_time))" -gt "$((max_keep_changed_days*86400))"; then
		remove_list+=("$i")
	    fi
	done
    fi

}

backup_from_host bergenrabbit bergenrabbit.net

if [[ ${#remove_list[@]} -ne 0 ]]; then
    printf -v s "\\n\\t%s" "${remove_list[@]}"
    echo "removing older changes created more than $max_keep_changed_days days ago:$s"
    rm -rf "${remove_list[@]}"
fi

'

    p_file scripts:bergenrabbit-backup.bash "$s"

    if let kind_fedora; then
	setsebool rsync_client 1
    fi
}

setup_services() {
    log "Checking services"
    inc_log_level

    setup_bergenrabbit_backup

    if let with_docker; then
	# Make sure that docker starts. On CoreOS docker is
	# socket-activated by default which breaks restarting
	# containers on boot unless a docker client runs
	if ! under_qubes; then
	    multi_user_wants+=(docker.service)
	fi

	local docker_lib_dir=
	if under_qubes; then
	    docker_lib_dir=/rw/varlib/docker
	fi
	local docker_service_lines=()
	if [[ $docker_lib_dir ]]; then
	    local unit
	    unit="$(systemd-escape -p "/var/lib/docker").mount"
	    p_file "service:$unit" "\
[Mount]
Where=/var/lib/docker
Type=none
Options=bind
What=$docker_lib_dir
"
	    docker_service_lines+=(
		"[Unit]"
		"BindsTo=$unit"
		"After=$unit"
	    )
	fi

	if let kind_fedora; then
	    p_mask_service docker-storage-setup.service
	    local exec_start=(
		/usr/bin/dockerd-current
		--add-runtime oci=/usr/libexec/docker/docker-runc-current
		--default-runtime=oci
		--containerd /run/containerd.sock
		--exec-opt native.cgroupdriver=systemd
		--userland-proxy=false
		--log-driver=journald
		--storage-driver=overlay2
	    )
	    docker_service_lines+=(
		"[Service]"
		"ExecStart="
		"ExecStart=${exec_start[*]}"
	    )
	fi

	if [[ $NAME == r2 ]]; then
	    docker_service_lines+=(
		"[Service]"
		"Environment=DOCKER_OPTS=--userland-proxy=false"
		"[Unit]"
		"[]"
	    )

	fi

	if [[ ${#docker_service_lines[@]} -ne 0 ]]; then
	    local text
	    printf -v text '%s\n' "${docker_service_lines[@]}"
	    p_systemd_drop_in docker.service "$text"
	fi
    fi

    dec_log_level
}

setup_files() {
    case $NAME in
    r2 )
	ensure_dir /opt /opt/dpodctl "/opt/dpodctl/transdock"
	write_file "/opt/dpodctl/transdock/config.dpod" "\
ImageName local/transdock
HostEnv TLS_HOSTS media.mir2.org
HostEnv ACME_CONTACT mailto:igor@mir2.org
UseHostNetwork
"
	;;
    rhea )
	ensure_dir -m 0755 /vol
	;;
    thip )
	ensure_dir -m 0755 /vol
	ensure_dir -m 0770 -u root -g core /vol/projects
	;;
    esac

}

setup_accounts() {
    if let with_sudoless_docker; then
	if [[ -z ${SUDO_USER-} ]]; then
	    err "cannot determine the user for the docker command - SUDO_USER is not defined"
	fi
	local primary_user
	primary_user="${SUDO_USER}"
	local s
	s="$(getent group docker 2>/dev/null || :)"
	if [[ ! $s  ]]; then
	    cmd_log groupadd docker
	fi
	if ! [[ $s =~ ^[^:]+:[^:]*:[^:]+:(.*,)?"$primary_user"(,|$) ]]; then
	    cmd_log usermod -aG docker "$primary_user"
	fi
    fi
}

start_docker_container() {
    local container dockerfile run_args cmd_arg
    container="$1"
    dockerfile="$2"
    run_args="$3"
    cmd_args="${4-}"

    local image
    image="local/${container}"
    escape_for_shell "${image}"
    run_args="${run_args} ${R}${cmd_args:+ }${cmd_args}"

    local tag
    escape_for_shell "${dockerfile}"
    tag="$(printf '%s %s' "${R}" "${run_args}"| sha256sum)"
    tag="${tag%% *}"

    local s
    s="$(docker inspect --type container \
	-f  '{{.State.Running}} {{index .Config.Labels "local.tag"}}' \
	"${container}" 2>/dev/null || :)"

    local status current_tag
    status="${s%% *}"
    current_tag="${s#* }"
    if test true != "${status}" -o "x${current_tag}" != "x${tag}"; then
	log "Starting ${container} container"
	if test true = "${status}"; then
	    cmd_log docker stop "${container}" > /dev/null
	fi
	if test -n "${status}"; then
	    cmd_log docker rm -v "${container}" > /dev/null
	fi
	printf %s "${dockerfile}" | cmd_log docker build -t "${image}" -
	escape_for_shell cmd_log docker run -d --name "${container}" --label local.tag="${tag}"
	eval "${R} ${run_args} > /dev/null"
    fi
}

setup_docker_services() {
    let with_docker || return 0

    if ! docker version -f '{{.Server.Version}}' > /dev/null 2>&1; then
	log "Attempting to start the docker daemon"
	cmd_log systemctl start docker
    fi

    if let with_docker_development_net; then
	local net_name="development"
	local subnet_template
	subnet_template='{{range .IPAM.Config}}{{if .Subnet}}{{.Subnet}}{{end}}{{end}}'
	local subnet="${dev_docker_network_prefix}.0/24"
	local actual_subnet=
	docker network inspect -f "$subnet_template" "$net_name" 2> /dev/null \
	    | read -r actual_subnet || :
	if [[ $actual_subnet != "$subnet" ]]; then
	    log "Creating docker subnet $subnet"
	    if [[ $actual_subnet ]]; then
		cmd_log docker network rm "$net_name" > /dev/null
	    fi
	    local eargs
	    eargs=
	    earg --subnet="${subnet}"
	    earg --gateway="${dev_docker_network_prefix}.1"
	    earg "${net_name}"

	    eval "cmd_log docker network create ${eargs} > /dev/null"
	fi

	local extra_dnsmasq_eargs
	extra_dnsmasq_eargs=
	if test thip = "${NAME}"; then
	    setup_development_dpodctl
	fi

	if test thip = "${NAME}"; then

	    local host
	    for host in ${bergenrabbit_dns}; do
		add_dns_record_a "${host}" "${dev_vz_network_prefix}.100"
	    done
	    add_dns_record_a "boulder" "${dev_docker_network_prefix}.50"
	    #add_dns_interface_name "boulder" "eth0"

	    local container
	    container=dnsmasq
	    local dockerfile
	    IFS= read -r -d '' dockerfile <<EOF || :
FROM alpine:latest
RUN apk update && apk --no-cache add dnsmasq && rm -rf /var/cache/apk/*
EOF
	    local eargs
	    eargs=
	    earg --restart=unless-stopped
	    earg --net=host
	    earg --cap-add=NET_ADMIN
	    earg -v /run/systemd/resolve:/run/systemd/resolve

	    earg -v /dev/log:/dev/log
	    earg --log-driver=syslog
	    earg --log-opt syslog-facility=local1
	    earg --log-opt tag="${container}"

	    local docker_run_eargs
	    docker_run_eargs="${eargs}"

	    eargs=
	    earg -k
	    earg --no-resolv
	    #earg --resolv-file=/run/systemd/resolve/resolv.conf
	    earg --server=10.0.2.3
	    earg --localise-queries
	    earg --dhcp-range="${dev_vz_network_prefix}.100,${dev_vz_network_prefix}.199"
	    earg --dhcp-host="test-br,${dev_vz_network_prefix}.100"

	    eargs="${eargs}${extra_dnsmasq_eargs}"

	    start_docker_container "${container}" "${dockerfile}" \
		"${docker_run_eargs}" "dnsmasq ${eargs}"

	    write_file "/etc/resolv.conf" "nameserver 127.0.0.1${NL}"
	fi
    fi
}

setup_development_dpodctl() {
    local net_name="development"

    local dir="/opt/dpodctl"
    ensure_dir /opt/dpodctl

    local projects_root="/vol/projects"

    local i ip4_last_byte=10
    for i in transdock; do
	ensure_dir "$dir/$i"
	local ipv4="$dev_docker_network_prefix.$ip4_last_byte"
	: $((ip4_last_byte+=1))
	case $i in
	transdock )
	    add_dns_record_a media.mir2.org "${ipv4}"
	    add_dns_record_a test.media.mir2.org "${ipv4}"
	    write_file "$dir/$i/config.dpod" "\
IncludeBuild $projects_root/$i/config.dpod
DnsAlias media.mir2.org
DnsAlias test.media.mir2.org
HostEnv ACMELOOP_HOST 'media.mir2.org test.media.mir2.org'
HostEnv ACMELOOP_CA http://boulder:4000/directory
HostEnv ACMELOOP_CONTACT mailto:igor@mir2.org

HostEnv TLS_HOSTS 'media.mir2.org test.media.mir2.org'
HostEnv ACME_CA http://boulder:4000/directory
HostEnv ACME_CONTACT mailto:igor@mir2.org
BindAddress none
Network $net_name
NetworkIPv4 $ipv4
"
	    ;;
	esac
    done
}

run_remotely() {
    local OPTIND opt ssh_user machine_host
    ssh_user=root
    machine_host=
    while getopts :m:u: opt; do
	case "$opt" in
	m ) machine_host="${OPTARG}";;
	u ) ssh_user="${OPTARG}";;
	* ) getopts_err "$opt" "${OPTARG-}";;
	esac
    done
    shift $(($OPTIND - 1))

    local target_host="$1"
    shift

    # I need to send the directory and allow to use terminal to ask
    # for password or secreets. So just emebedd the archive into the
    # command as base64 and ensure that ssh allocates tty.
    local data=$(tar -C "${selfdir}" --exclude .git --exclude README.md --exclude LICENSE -cf - . | gzip -9 | base64 -w0)

    local i cmd
    cmd=$(printf %q "/tmp/tliset/$(basename "$0")")
    for i in "$@"; do
	cmd+=" $(printf %q "$i")"
    done

    local cmd="rm -rf /tmp/tliset && mkdir /tmp/tliset && printf %s $data | base64 -d | tar -C /tmp/tliset -xzf - && $cmd"

    local wrapped_cmd
    if [[ ${machine_host} ]]; then
	wrapped_cmd="systemd-run -M ${target_host} --quiet --tty --wait"
	wrapped_cmd+=" /bin/bash -c $(printf %q "$cmd")"
	if [[ ${ssh_user} != root ]]; then
	    wrapped_cmd="sudo ${wrapped_cmd}"
	fi
	target_host="${machine_host}"
    elif [[ ${ssh_user} != root ]]; then
	wrapped_cmd="sudo /bin/bash -c $(printf %q "$cmd")"
    else
	wrapped_cmd="${cmd}"
    fi
    exec ssh -t "${ssh_user}@${target_host}" "${wrapped_cmd}"
}


show_usage=""
NAME=""
remote=""

while getopts :hn:r:u: opt; do
    case "$opt" in
	h ) show_usage=1 ;;
	n )
	    NAME="$OPTARG"
	    is_valid_host_name "$NAME" || \
		usage_err "The value of -n argument '$NAME' is not a known host name."
	    ;;
	r )
	    remote="$OPTARG"
	    is_valid_host_name "$remote" || \
		usage_err "The value of -r argument '$remote' is not a known host name."
	    ;;
	* ) getopts_err "$opt" "${OPTARG-}";;
    esac
done

#[[ $# -eq $(($OPTIND - 1)) ]] || usage_err "Unexpected extra arguments: $@"
let OPTIND==1+$# || usage_err "Unexpected extra arguments: $@"

[[ -z "$remote" || -z "$NAME" ]] || usage_err "Only one of -n, -r can be given"

if [[ -n "$show_usage" ]]; then
    echo "Usage: $0 [OPTION]..."
    echo "Customize installation for the given computer."
    echo
    echo "  -h  show this help and exit"
    echo "  -n name  assume the given name as the hostname rather than use /etc/hostname."
    echo "           The valid values are (${valid_host_names[*]})."
    echo "  -r name  execute setup on the remote machine name using ssh to copy the setup files."
    echo
    exit
fi

if [[ $remote ]]; then
    NAME=$remote
elif [[ -z "$NAME" ]]; then
    read_tliset_name
    NAME="$R"
fi

get_host_options

if [[ -n "$remote" ]]; then
    cmd=(run_remotely)
    if [[ ${machine_host} ]]; then
	cmd+=(-m "${machine_host}")
    fi
    if [[ ${ssh_login_user} ]]; then
	cmd+=(-u "${ssh_login_user}")
    fi
    "${cmd[@]}" -- "$remote" -n "$remote"
fi

if [[ "$(id -u)" -ne 0 ]]; then
    exec sudo "$0" "$@"
fi

determine_os

if let kind_fedora; then
    fedora_release="$(rpm -E %fedora)"
fi

begin_tliset

if ! under_qubes; then
    setup_packages
fi

start_generator_write

setup_kernel_parameters
setup_network
setup_services
setup_files
setup_accounts

finish_generator_write

# Run services after the docker is configured
setup_docker_services

end_tliset

log "Done."
