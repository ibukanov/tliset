#!/bin/bash

source "$(dirname "$0")/lib.bash"

valid_host_names=(miranda ultrabook untrusted bergenrabbit hippyru lubavainfo thip r2 nicarnica titan)

declare -i kind_coreos=0
declare -i kind_fedora=0
declare -i kind_ubuntu=0
declare -i with_vol_storage=0
declare -i with_zram=1
declare -i with_networkd=0
declare -i with_networkd_if_virt=0
declare -i with_dyndns=0
declare -i with_kino_access=0
declare -i with_latex=0
declare -i with_transgui=0
declare -i with_hippyru_www_access=0
declare -i with_common_fedora_packages=0
declare -i with_common_ubuntu_packages=0

declare -i with_enabled_sshd=1
declare -i sshd_extra_listen_port=0

declare hippyru_backup_time=

declare single_ssh_user=
declare downloads_user=

# Replace lables/uids with real devices in fstab/grub for security
# when allowing untrusted VM to access the whole disk.
declare -i with_disabled_disk_uuid=0

declare -i with_dnsmasq=0

readonly virt_net_ipv4_prefix="192.168.95"

readonly gen_self_dir=/tun/tliset
readonly gen_scripts="$gen_self_dir"
readonly gen_config="$gen_self_dir"
readonly gen_mount="$gen_self_dir/set"

get_host_options() {
    case "$NAME" in
	ultrabook )
	    kind_fedora=1
	    with_common_fedora_packages=1
	    with_transgui=1
	    with_kino_access=1
	    with_hippyru_www_access=1
	    #with_enabled_sshd=1
	    ;;
	miranda )
	    kind_fedora=1
	    with_networkd_if_virt=1
	    with_common_fedora_packages=1
	    with_latex=1
	    with_enabled_sshd=0
	    sshd_extra_listen_port=19022
	    with_hippyru_www_access=1
	    with_kino_access=1
	    downloads_user=igor
	    ;;
	titan )
	    kind_fedora=1
	    with_networkd_if_virt=1
	    with_common_fedora_packages=1
	    with_latex=1
	    with_enabled_sshd=0
	    ;;
	untrusted )
	    kind_fedora=1
	    with_common_fedora_packages=1
	    with_networkd=1
	    with_kino_access=1
	    with_transgui=1
	    downloads_user=user
	    single_ssh_user=user
	    ;;
	thip )
	    kind_coreos=1
	    with_vol_storage=1
	    ;;
	bergenrabbit | hippyru | lubavainfo )
	    kind_coreos=1
	    ;;
 	r2 )
	    kind_coreos=1
	    hippyru_backup_time=03:00:02
	    ;;
 	nicarnica )
	    kind_ubuntu=1
	    single_ssh_user=user
	    with_networkd_if_virt=1
	    with_common_ubuntu_packages=1
	    ;;
	* )
	    err "unknown '$NAME'"
	    ;;
    esac
    if let kind_coreos; then
	with_networkd=1
	single_ssh_user=core
    fi
}

# Array of (host-name space-separated-list-of-net-ids) where the ids
# are used to construct ip addresses assigned to virtual net
# interface.
readonly -a virt_net_host_info=(
    miranda 10
    untrusted 11
    thip "12 13 14 15 16"
    nicarnica 30
)

# Add to virt_net_ids array net ids cooresponding to the host
add_virt_net_ids() {
    local i
    for ((i=0; i<${#virt_net_host_info[@]}; i+=2)); do
	local host="${virt_net_host_info[$((i+0))]}"
	local ids="${virt_net_host_info[$((i+1))]}"
	if [[ $host == $NAME ]]; then
	    virt_net_ids+=($ids)
	    return 0
	fi
    done
    err "$NAME is not on the $virt_net_host_info list"
}


is_valid_host_name() {
    local name="$1" i
    for i in "${valid_host_names[@]}"; do
	if [[ "$i" == "$name" ]]; then
	    return 0
	fi
    done
    return 1;
}

fixup_transgui() {
    local path=/usr/share/applications/transgui.desktop
    local line='MimeType=application/x-bittorrent;x-scheme-handler/magnet;'
    if ! grep -q "^$line\$" "$path" ; then
	log "fixing $path"
	local data="$(cat "$path" | grep -v '^MimeType=')"
	local tmp="$(mktemp "$path.XXXXXXXXXX")"
	tmp_files+=($tmp)
	printf '%s\n%s\n' "$data" "$line" > "$tmp"
	chmod 644 "$tmp"
	mv "$tmp" "$path"
    fi
}

setup_packages() {
    let kind_fedora || let kind_ubuntu || return 0

    log "Checking packages"
    inc_log_level
    let kind_fedora && setup_fedora_packages
    let kind_ubuntu && setup_ubuntu_packages
    dec_log_level
    return 0
}


setup_fedora_packages() {
    if let with_common_fedora_packages; then
	local rpmfusion_kinds=(
	    free
	    nonfree
	)
	local i rpmfusion_repos=()
	for i in "${rpmfusion_kinds[@]}"; do
	    rpmfusion_repos+=("rpmfusion-$i-release")
	done

	if ! rpm -q --quiet "${rpmfusion_repos[@]}" ; then
	    log "Installing rpmfusion"
	    local urls=()
	    for i in "${rpmfusion_kinds[@]}"; do
		urls+=("http://download1.rpmfusion.org/$i/fedora/rpmfusion-$i-release-$fedora_release.noarch.rpm")
	    done
	    dnf install -y --nogpgcheck "${urls[@]}" || true
	fi
    fi
    local list=()
    if let with_common_fedora_packages; then
	list+=(
	    tmux xfce4-terminal
	    git fuse-sshfs sshpass lsyncd
	    quilt mercurial subversion
	    livecd-tools
	    autoconf automake gcc-c++ kernel-devel
	    emacs
	    tigervnc
	    strace
	    policycoreutils-python-utils
	    xclip

	    # filesystems
	    udftools inotify-tools fdupes fslint

	    # Archives
	    unrar libunrar

	    # encryption and backup
	    apg duplicity perl-Digest-Bcrypt python-gdata

	    # Recovery tools
	    ddrescue foremost scalpel testdisk

	    # Graphs
	    graphviz graphviz-doc

	    # PDF tools
	    pdfmerge poppler-utils

	    # Media
	    kdenlive
	    ffmpeg
	    vlc gimp inkscape gthumb
	    scribus
	    evince evince-djvu pdf2djvu
	    linux-libertine-biolinum-fonts linux-libertine-fonts
	    gstreamer1-libav
	    gstreamer1-plugins-bad-free
	    gstreamer1-plugins-bad-free-extras
	    gstreamer1-plugins-bad-freeworld
	    gstreamer1-plugins-good-extras
	    gstreamer1-plugins-ugly

	    # Languages
	    hunspell-ru hunspell-nb
	)

	if [[ -z "$virt" ]]; then
	    list+=(
		# hardware management
		rfkill lm_sensors
	    )


	    list+=(
		# Assume this is only necessary on real hardware
		gnome-tweak-tool
		gnome-terminal-nautilus
		gnome-shell-extension-alternate-tab
	    )
	fi
    fi

    let with_latex && list+=(
	    texlive
	    texlive-babel-norsk
	    texlive-babel-russian
	    texlive-collection-langcyrillic
	)
    let with_transgui && list+=(transgui openssl-devel)

    if [[ -n "$virt" ]]; then
	list+=(gcc kernel-devel)
    fi

    case "$NAME" in
	miranda )
	    list+=(
		virt-manager
		virt-viewer
		docker
	    )
	    if [[ -z "$virt" ]]; then
		list+=(
		    libvirt-daemon-config-network
		    libvirt-daemon-kvm
		    qemu-kvm
		)
	    fi
	    ;;
    esac

    if [[ "$NAME" == miranda ]]; then
	list+=(tinyproxy firefox)
    fi

    for i in "${list[@]}"; do
	rpm -q --quiet "$i" || echo "Missed: $i"
    done

    if ! rpm -q --quiet "${list[@]}" ; then
	log "Installing missing packages"
	dnf install -y "${list[@]}"
    fi

    local remove_list=()

    if let with_transgui; then
	remove_list+=(transmission-gtk transmission-remote-gtk)
    fi
    if let with_networkd; then
	remove_list+=(network-manager-applet)
    fi
    if [[ "$NAME" == miranda ]]; then
	# No need to keep midori browser
	remove_list+=(midori)
    fi
    if let ${#remove_list[@]}; then
	local status=0
	rpm -q --quiet "${remove_list[@]}" || status=$?
	if let "status < ${#remove_list[@]}"; then
	    cmd_log dnf remove -y "${remove_list[@]}"
	fi
	fixup_transgui
    fi

    printf 'new-session\n' | write_file /etc/tmux.conf
}

setup_ubuntu_packages() {
    local -a install_list=() remove_list=()
    install_list+=(
	make make-doc gcc "linux-headers-$(uname -r)"
	git git-man liberror-perl
	emacs24 emacs24-el xterm xfonts-base
	xtightvncviewer
    )

    if let with_common_ubuntu_packages; then
	install_list+=(
	    libreoffice
	    gvfs-bin
	)
    fi
    
    if let with_networkd; then
	remove_list+=(resolvconf)
    else
	install_list+=(resolvconf)
    fi

    local -A package_status_map=()

    local -a apt_action_list=()
    fill_apt_action_list install "${install_list[@]:+${install_list[@]}}"
    if [[ ${#apt_action_list[@]} -ne 0 ]]; then
	log "Installing missing packages"
	DEBIAN_FRONTEND=noninteractive cmd_log apt-get install -y "${apt_action_list[@]}"
    fi

    local -a apt_action_list=()
    fill_apt_action_list uninstall "${remove_list[@]:+${remove_list[@]}}"
    if [[ ${#apt_action_list[@]} -ne 0 ]]; then
	log "Purging unnecessary packages"
	DEBIAN_FRONTEND=noninteractive apt-get purge -y "${apt_action_list[@]}"
    fi
}

fill_apt_action_list() {
    local action="$1"
    shift

    # Complication: for unknown packages dpkg-query reports an error,
    # so parse both stdout and stderr.
    local status_package_re='^#stdout ([^ ]+) ([^ ]+)$'
    local unknown_package_message_re='^dpkg-query: no packages found matching ([^ ]+)$'
    local output
    output="$(dpkg-query -W --showformat '#stdout ${db:Status-Status} ${Package}\n' "$@"  2>&1 || :)"
    if [[ $output ]]; then
	local -a lines
	mapfile -t lines <<< "$output"
	local line
	for line in "${lines[@]}"; do
	    if [[ $line =~ $unknown_package_message_re ]]; then
		local package="${BASH_REMATCH[1]}"
		local status="unknown"
	    elif [[ $line =~ $status_package_re ]]; then
		local status="${BASH_REMATCH[1]}"
		local package="${BASH_REMATCH[2]}"
		package_status_map[$package]="$status"
	    else
		err "unexpected dpkg-query output: $line"
	    fi
	    if [[ $action == install ]]; then
		if [[ $status == installed ]]; then
		    continue
		fi
	    elif [[ $action == uninstall ]]; then
		# purge both installed packages and packages with config-files
		if [[ $status != installed && $status != config-files ]]; then
		    continue
		fi
	    else
		err "bad action: $action"
	    fi
	    apt_action_list+=("$package")
	done
    fi
}

remove_fstab_uuids() {
    log "Checking /etc/fstab"
    local fstab
    IFS='' read -rd '' fstab < /etc/fstab
    local -a ids
    ids=($(egrep -o '^UUID=[A-Fa-f0-9-]+' <<< "$fstab" | cut -d= -f2 || true))
    if [[ ${#ids[@]} -ge 1 ]]; then
	log "replacing UUID with devices for security with untrusted VM"
	local -a edits=()
	local id
	for id in "${ids[@]}"; do
	    [[ -b "/dev/disk/by-uuid/$id" ]] || err "failed to locate disk for uuid=$id"
	    local resolved disk
	    resolved="$(readlink "/dev/disk/by-uuid/$id")"
	    disk="/dev/$(basename "$resolved")"
	    [[ -b "$disk" && ! -h "$disk" ]] || \
		err "/dev/disk/by-uuid/$id does not point to real device file"
	    edits+=(-e "s|^UUID=$id|$disk|")
	done
	fstab="$(printf %s "$fstab" | sed "${edits[@]}")"
    fi

    write_file /etc/fstab "$fstab"
    if let file_update; then
	log "/etc/fstab was updated"
    fi
}

setup_fstab() {
    log "Checking fstab"
    local fstab ids edits id disk
    inc_log_level
    if let with_disabled_disk_uuid; then
	remove_fstab_uuids
    fi

    if [[ -n "$downloads_user" ]]; then
	local dirname=downloads
	local dir="/$dirname"
	local unitname="$dirname"
	if [[ ! -d "$dir" ]]; then
	    # TODO find out why systemd does not create the dir
	    # automatically.
	    cmd_log mkdir -m 0755 "$dir"
	fi
	if [[ -n "$virt" ]] ; then
	    p_nl
	    p_file "service:$unitname.mount" "\
[Mount]
Where=$dir
Type=vboxsf
What=Downloads
Options=uid=$downloads_user,gid=$downloads_user,nosuid,nodev
"
	    p_file "service:$unitname.automount" "\
[Automount]
Where=$dir
"
            multi_user_wants+=("$unitname.automount")
	fi
    fi
    dec_log_level
}

setup_grub() {

    let kind_fedora || let kind_ubuntu || return 0

    log "Checking grub"

    local net_kernel_options=""
    if [[ $virt ]]; then
	# Disable predictable interface names under VM as they
	# complicates autoconfig.
	if let kind_fedora || let kind_ubuntu; then
	    net_kernel_options=" net.ifnames=0"
	fi
    fi

    local -a config=(
	GRUB_TIMEOUT 0
	GRUB_HIDDEN_TIMEOUT 1
	GRUB_DEFAULT saved
    )

    if let kind_fedora; then
	config+=(GRUB_CMDLINE_LINUX "rhgb quiet LANG=en_US.UTF-8$net_kernel_options")
    elif let kind_ubuntu; then
	config+=(GRUB_CMDLINE_LINUX "LANG=C.UTF-8$net_kernel_options")
    fi

    if let with_disabled_disk_uuid; then
	# Avoid UUID for VM security
	config+=(
	    GRUB_DISABLE_LINUX_UUID true
	)
    fi

    local -A config_keys=()
    local i
    for ((i=0; i<${#config[@]}; i+=2)); do
	config_keys[${config[$i]}]="$i"
    done

    # copy to new_lines only lines that do not match keys then append
    # the proper key=value.
    local -a lines new_lines=()
    mapfile -t lines < /etc/default/grub
    local line
    for line in "${lines[@]}"; do
	if [[ $line =~ ^[[:space:]]*([^=]+)= ]]; then
	    local key="${BASH_REMATCH[1]}"
	    if [[ ${config_keys[$key]-} ]]; then
		continue
	    fi
	fi
	new_lines+=("$line")
    done

    for ((i=0; i<${#config[@]}; i+=2)); do
	escape_for_shell "${config[$((i+1))]}"
	new_lines+=("${config[$i]}=$R")
    done

    local new_text
    printf -v new_text '%s\n' "${new_lines[@]}"

    if let kind_fedora; then
       local grub_config=/boot/grub2/grub.cfg
       [[ -f "$grub_config" ]] || grub_config=/boot/efi/EFI/fedora/grub.cfg
    elif let kind_ubuntu; then
	local grub_config=/boot/grub/grub.cfg
    fi
    [[ -f "$grub_config" ]] || err "Failed to locate grub.cfg"

    write_file /etc/default/grub "$new_text"
    if let file_update; then
	log "updating $grub_config"
	if let kind_fedora; then
	   grub2-mkconfig -o "$grub_config"
	else
	   grub-mkconfig -o "$grub_config"
	fi
    fi
}

setup_sudo() {
    let kind_fedora || let kind_ubuntu || return 0
    [[ $virt ]] || return 0

    if let kind_fedora; then
	local sudo_with_password_re='^%wheel[[:space:]]+ALL=\(ALL\)[[:space:]]+ALL$'
	local sudo_without_password="%wheel ALL=(ALL) NOPASSWD: ALL"
    elif let kind_ubuntu; then
	local sudo_with_password_re='^%sudo[[:space:]]+ALL=\(ALL:ALL\)[[:space:]]+ALL$'
	local sudo_without_password="%sudo ALL=(ALL:ALL) NOPASSWD: ALL"
    fi

    local -a lines new_lines=()
    mapfile -t lines < /etc/sudoers
    local i should_patch=0 already_patched=0
    for ((i=0; i<${#lines[@]}; i+=1)); do
	local line="${lines[$i]}"
	if [[ $line =~ $sudo_with_password_re ]]; then
	    lines[$i]="$sudo_without_password"
	    should_patch=1
	elif [[ $line == "$sudo_without_password" ]]; then
	    already_patched=1
	fi
    done
    if let should_patch==0; then
	let already_patched || err "/etc/sudoers contains neither unpatched no patched lines"
	return 0
    fi
    let already_patched==0 || err "/etc/sudoers contains both unpatched and patched lines"

    local new_text
    printf -v new_text '%s\n' "${lines[@]}"
    write_file -m 660 /etc/sudoers "$new_text"
}

setup_network() {
    log "Checking network"
    inc_log_level

    # Array of (hostname ip)
    local -a hosts=()
    if let with_virtual_box_network; then
	local i
	for ((i=0; i<${#virt_net_host_info[@]}; i+=2)); do
	    local host="${virt_net_host_info[$((i+0))]}"
	    local ids="${virt_net_host_info[$((i+1))]}"
	    if [[ $host != "$NAME" ]]; then
		hosts+=("$host" "$virt_net_ipv4_prefix.${ids%% *}")
	    fi
	done
    fi

    if [[ ${#hosts[@]} -ne 0 ]]; then
	local prefix_line='# auto-generated entries, do not edit after this line'
	local -A ipv4_map=()
	local i
	for ((i=0; i<${#hosts[@]}; i+=2)); do
	    local host="${hosts[$((i+0))]}"
	    local ipv4="${hosts[$((i+1))]}"
	    ipv4_map[$ipv4]="$host"
	done
	local -a lines new_lines=()
	mapfile -t lines < /etc/hosts

	# remove old mappings for the address
	local line
	for line in "${lines[@]:+${lines[@]}}"; do
	    if [[ $line == "$prefix_line" ]]; then
		continue
	    fi
	    if [[ $line =~ ^[[:blank:]]*([^[:blank:]]+)[[:blank:]]+ ]]; then
		local token="${BASH_REMATCH[1]}"
		if [[ ${ipv4_map[$token]-} ]]; then
		    continue
		fi
	    fi
	    new_lines+=("$line")
	done
	new_lines+=("$prefix_line")
	for ((i=0; i<${#hosts[@]}; i+=2)); do
	    local host="${hosts[$((i+0))]}"
	    local ipv4="${hosts[$((i+1))]}"
	    new_lines+=("$ipv4 $host")
	done
	local hosts_text
	printf -v hosts_text '%s\n' "${new_lines[@]}"
	write_file /etc/hosts "$hosts_text"
    fi

    if let with_networkd; then
	# networkd implies resolved
	if [[ ! -L /etc/resolv.conf || \
		    "$(readlink /etc/resolv.conf)" != /run/systemd/resolve/resolv.conf ]]; then
	    cmd_log ln -s -f /run/systemd/resolve/resolv.conf /etc/resolv.conf
	fi

	# For now do not switch glib resolver to use systemd-resolved
	# to avoid differences between static and non-static builds.
	#
	#if grep -q '^hosts:.*\<dns\>' /etc/nsswitch.conf; then
	#    sed -i -e 's/^\(hosts:.*\)\<dns\>/\1resolve/' /etc/nsswitch.conf
	#fi
    fi

    print_network
    if let with_dyndns; then
	print_dyndns
    fi
    if let with_dnsmasq; then
	print_dserver_dnsmasq
    fi

    case "$NAME" in
	miranda ) install_miranda_network ;;
    esac

    dec_log_level
}

# Escape argument using single quotas with with each single quote in
# arg replaced by '"'"'
escape_for_shell() {
    local arg="$1"
    if [[ $arg =~ ^[-_./a-zA-Z0-9]+$ ]]; then
	R="$arg"
    else
	local escaped=
	while : ; do
	    local before_quote="${arg%%\'*}"
	    [[ $arg != "$before_quote" ]] || break
	    escaped="$escaped$before_quote'\"'\"'"
	    arg="${arg#*\'}"
	done
	printf -v R %s "'$escaped$arg'"
    fi
}

start_generator_write() {
    multi_user_wants=()
    sockets_wants=()
    gen_body=()
    gen_mkdir_list=()
}

print_wants_list() {
    local target="$1"
    shift
    let $# || return 0
    p_nl
    p_dir "service:$target.d"
    local i wants_body="[Unit]$NL"
    for i in "$@"; do
	wants_body+="Wants=$i$NL"
    done
    p_file "service:$target.d/tliset.conf" "$wants_body"
}

finish_generator_write() {
    p_dir scripts:
    print_wants_list multi-user.target "${multi_user_wants[@]:+${multi_user_wants[@]}}"
    print_wants_list sockets.target "${socket_wants[@]:+${socket_wants[@]}}"
    
    local script="#!/bin/sh$NL"
    if true; then
	script+='
if [[ -z "${TLISET_HAS_LOG-}" ]]; then
    export TLISET_HAS_LOG=1
    exec "$0" "$@" > /run/tliset.log 2>&1
fi
date '+%Y-%m-%d_%H:%M:%S'
set -x
'
    fi
    script+="\
set -u

mkdir -p ${gen_mkdir_list[*]}
"
    if [[ ${#gen_body[@]} -ne 0 ]]; then
	local gen_body_txt
	printf -v gen_body_txt '%s\n' "${gen_body[@]}"
	script+="$gen_body_txt"
    fi

    ensure_dir /etc/systemd/system-generators
    write_file -m 755 /etc/systemd/system-generators/tliset "$script"
    if let file_update; then
	cmd_log systemctl daemon-reload
    fi
}

p_add_raw() {
    gen_body+=("$1")
}

p_nl() {
    p_add_raw ''
}

# The first argument is <kind>:<subpath> where kind specifies
# directory kind and subpath is a file path. The second argument is
# text that should be written into the file at that path. Option -x
# indicattes that file must be executable.
p_file() {
    local -i executable=0
    if [[ "$1" == "-x" ]]; then
	shift
	executable=1
    fi
    local file_kind_and_path="$1"
    local body="$2"
    conert_shell_kind_path "$file_kind_and_path"
    local escaped_path="$R"
    escape_for_shell "$body"
    p_add_raw "> $escaped_path printf %s $R"
    if let executable; then
	p_add_raw "chmod 755 $escaped_path"
    fi
}

p_dir() {
    local dir="$1"
    conert_shell_kind_path "$dir"
    gen_mkdir_list+=("$R")
}

p_cmd() {
    local s="" arg
    for arg in "$@"; do
	if [[ $arg == *:* ]]; then
	    conert_shell_kind_path "$arg"
	else
	    escape_for_shell "$arg"
	fi
	s+="${s:+ }$R"
    done
    p_add_raw "$s"
}

conert_shell_kind_path() {
    local file_kind_and_path="$1"
    local file_kind="${file_kind_and_path%%:*}"
    [[ $file_kind != $file_kind_and_path ]] || err "the argument must start with <kind>: prefix"
    local file_path="${file_kind_and_path#*:}"
    local dir absolute=0
    case "$file_kind" in
	service ) dir='"$1"' ;;
	net ) dir='"$1"/../network' ;;
	config ) dir="$gen_config" ;;
	mount ) dir="$gen_mount" ;;
	scripts ) dir="$gen_scripts" ;;
	top ) dir="" ; absolute=1 ;;
	* ) err "Unknown dir_kind $dir_kind" ;;
    esac
    if let absolute; then
	[[ $file_path =~ ^/. ]] || err "$file_kind must come with absolute path: $file_kind_and_path"
    else
	if [[ $file_path == '' ]]; then
	    R="$dir"
	    return 0
	fi
	[[ $file_path =~ ^[^/] ]] || \
	    err "$file_kind must come with relative path: $file_kind_and_path"
	dir+="/"
    fi
    escape_for_shell "$file_path"
    R="$dir$R"
}

p_mask_service() {
    p_cmd ln -s /dev/null "service:$1"
}

print_network() {
    if let with_networkd; then
	if let kind_fedora || let kind_ubuntu; then
	    multi_user_wants+=(systemd-networkd.service systemd-resolved.service)
	    p_nl
	    p_dir service:sockets.target.d
	    p_file service:sockets.target.d/tliset.conf "\
[Unit]
Wants=systemd-networkd.socket
"
	    # Mask all NetworkManager-related services
	    p_mask_service NetworkManager.service
	    p_mask_service NetworkManager-dispatcher.service
	    p_mask_service NetworkManager-wait-online.service
	    p_mask_service firewalld.service
	    p_mask_service dbus-org.fedoraproject.FirewallD1.service

	    # Make sure that system-supplied dnsmasq is masked
	    p_mask_service dnsmasq.service
	fi
    else
	p_mask_service systemd-networkd.service
	p_mask_service systemd-resolved.service
    fi

    if let with_networkd; then
	p_nl
	p_dir net:

	if let kind_fedora; then
	    p_cmd chcon -t etc_t net:
	fi

	if [[ $NAME == dserver ]]; then
	    print_dserver_network_files
	elif let with_virtual_box_network; then
	    print_virtualbox_network
	elif let kind_fedora; then
	    print_fedora_networkd_files
	fi

	if [[ $NAME == r2 ]]; then
	    print_r2_default_net
	fi
    fi
}

print_dserver_network_files() {
    p_nl

    # Generate setup to allow for VMs that are accessible from the
    # lan. Use macvlan, not bridge, for beter efficiency.
    p_file net:0-macvlan.netdev "\
[NetDev]
Name=$dserver_bridge
Kind=macvlan
[MACVLAN]
Mode=bridge
"

    p_file net:80-lan.network "\
[Match]
MACAddress=80:ee:73:76:8f:4c
[Network]
MACVLAN=$dserver_bridge
"

    p_file net:80-macvlan.network "\
[Match]
Name=$dserver_bridge
[Network]
DHCP=ipv4
"

    # Print port forwarding initialization service and its scripts
    if false; then
	p_nl
	p_file service:tliset-forward-ports.service "\
[Unit]
After=network-online.target

[Service]
Type=oneshot
RemainAfterExit=true
ExecStart=/bin/sh $gen_scripts/open-ports.sh
ExecStop=/bin/sh $gen_scripts/close-ports.sh
"

	p_dir service:network-online.target.wants
	p_cmd ln -s service:tliset-forward-ports.service service:network-online.target.wants
	p_file scripts:open-ports.sh "$(print_dserver_port_forwards)"
    fi
}

# Output string for a script that runs iptables to setup port
# forwarding and generate another script to close those. This 2-stage
# generation allows to close ports using the old definition after the
# open part is changed with new defines.
print_dserver_port_forwards() {
    local open_text="#!/bin/sh$NL"
    local close_text="#!/bin/sh$NL"
    local i
    for i in "${dserver_port_forwards[@]}"; do
	if [[ "$i" =~ ^(tcp|udp):([0-9]+):([0-9.]+)(:([0-9]+))?$ ]]; then
	    local protocol="${BASH_REMATCH[1]}"
	    local wan_port="${BASH_REMATCH[2]}"
	    local lan_ip="${BASH_REMATCH[3]}"
	    local lan_port="${BASH_REMATCH[5]}"
	    if [[ -z "$lan_port" ]]; then
		lan_port="$wan_port"
	    fi
	    local s="PREROUTING -t nat -i $dserver_eth_wan -p $protocol --dport $wan_port -j DNAT --to $lan_ip:$lan_port"
	    open_text+="iptables -A $s$NL"
	    close_text+="iptables -D $s$NL"
	else
	    err "Bad port forwarding spec: $i"
	fi
    done

    escape_for_shell "$close_text"
    open_text+="> $gen_scripts/close-ports.sh printf %s $R$NL"
    printf %s "$open_text"
}

print_dyndns() {
    if [[ ! -s /etc/duckdns.key ]]; then
	[[ -t 1 ]] || err "cannot ask for /etc/duckdns.key value as input is not tty"
	local api_key
	IFS='' read -p 'Enter API key for www.duckdns.org: ' api_key
	write_file -m 640 -u root -g nobody /etc/duckdns.key "$api_key"
    fi
    local key="$(< /etc/duckdns.key)"
    local url="https://www.duckdns.org/update?domains=dsrv&token=$key&ip="

    multi_user_wants+=(tliset-dyndns.timer)
    p_nl
    p_file service:tliset-dyndns.timer "\
[Unit]
After=network-online.target
Wants=network-online.target

[Timer]
Persistent=true
# Each 10 minutes
OnCalendar=*:0/10
"
    p_file service:tliset-dyndns.service "\
[Unit]
After=network-online.target
Wants=network-online.target

[Service]
User=nobody
Type=oneshot
ExecStart=/bin/sh -c $gen_scripts/dyndns-update.sh
"
    escape_for_shell "$url"
    p_file scripts:dyndns-update.sh '
s="$(/usr/bin/curl -s $R)"
printf "curl output: %s\n" "$s" 1>&2
test OK = "$s"
'
}

print_dserver_dnsmasq() {

    local -a dnsmasq_config
    mapfile -t dnsmasq_config <<EOF

interface=$dserver_bridge
#interface=br0
domain-needed
bogus-priv

# for now use Google's services
no-resolv
server=8.8.8.8
server=8.8.4.4

no-hosts
dhcp-range=192.168.2.50,192.168.2.150,6h

address=/dserver/192.168.2.10
address=/dserver.mir2.org/192.168.2.10

dhcp-host=08:60:6E:CD:96:68,192.168.2.2
address=/wifi/192.168.2.2

# Virtual machine needs a stable ip to use with iptables rules
dhcp-host=$mac_kino,$ip_kino
address=/kino/$ip_kino
address=/extra.mir2.org/$ip_kino

dhcp-host=$mac_macbook_air,$ip_macbook_air

# Terentiy's tablet
dhcp-host=$mac_tablet,$ip_tablet

#dhcp-option=option:router,192.168.2.1
EOF

    # For simpler setup convert config into a list of options while
    # stripping spaces, comments and blunk lines and embedd it
    # directly into the unit file.
    local i s=''
    for i in "${dnsmasq_config[@]}"; do
	i="${i## }"
	i="${i%% }"
	i="${i%%#*}"
	if [[ -n "$i" ]]; then
	    s+=" \\$NL    --$i"
	fi
    done

    multi_user_wants+=(tliset-dnsmasq.service)

    p_nl
    p_file service:tliset-dnsmasq.service "\
[Unit]
After=network.target

[Service]
ExecStart=/usr/sbin/dnsmasq -k --conf-file=/dev/null$s
"
}

print_fedora_networkd_files() {
    p_file net:zz-default.network "\
[Network]
DHCP=ipv4

[DHCP]
UseMTU=true
UseDomains=true
"
}

print_r2_default_net() {
    p_file net:zz-default.network "\
[Network]
DHCP=ipv4

Address=2001:41d0:e:696::1/64
Gateway=2001:41d0:e:6ff:ff:ff:ff:ff

[DHCP]
UseMTU=true
UseDomains=true
"
}

print_virtualbox_network() {
    local -a virt_net_ids=()
    add_virt_net_ids
    local -a addresses=()
    for i in "${virt_net_ids[@]}"; do
	addresses+=("Address=$virt_net_ipv4_prefix.$i/24")
	addresses+=("Address=fda9:eefb:0a88:883f::$(printf %x "$i")/64")
    done

    p_file net:99-link-local.network "\
[Match]
Name=eth1

[Network]
$(printf '%s\n' "${addresses[@]}")
LLMNR=no
"
    p_file net:9a-default.network "\
[Network]
DHCP=yes
LLMNR=no

[DHCP]
UseMTU=yes
UseDNS=yes
"
}

install_miranda_network() {

    if [[ -z "$virt" ]]; then
	# TODO use dnsmasq to integrate with VM names
	write_file /etc/NetworkManager/conf.d/99-local.conf <<EOF
[main]
#dns=dnsmasq
EOF
	if let file_update; then
	    cmd_log systemctl restart NetworkManager
	fi
    fi
}

ensure_root_ssh_key() {
    local prefix=$1
    local file=/root/.ssh/$prefix-ed25519
    if [[ ! -s "$file" ]]; then
	cmd_log mkdir -p -m 0700 /root/.ssh
	cmd_log ssh-keygen -t ed25519 -N '' -f "$file"
    fi
    ssh_key_file="$file"
}

setup_kino_password() {
    if ! [[ -f $kino_password_file ]]; then
	(umask 077 && printf '' > "$kino_password_file")
    fi
    if ! [[ -s $kino_password_file ]]; then
	local password
	read -p "Enter password for kino access (it will be echoed): " -r password
	[[ $password ]] || err "password cannot be empty"
	printf '%s\n' "$password" > $kino_password_file
    fi
    escape_for_shell "$kino_password_file"
    local password_file="$R"
    p_file -x "top:$ssh_kino_wrap" "\
#/bin/sh
exec sshpass -f $password_file ssh \"\$@\"
"
}

setup_net_mounts() {

    local -a autofs_dirs=()
    if let with_kino_access; then
	autofs_dirs+=(kino)
	setup_kino_password
    fi
    if let with_hippyru_www_access; then
	autofs_dirs+=(bergenrabbit hippyru lubavainfo)
    fi
    if [[ $NAME == miranda ]]; then
	autofs_dirs+=(dzetacon)
    fi

    [[ ${#autofs_dirs[@]} -ne 0 ]] || return 0

    p_dir ${autofs_dirs[*]/#/mount:}

    local s="" dir host host_key_alias host_pubkey port keyfile remote_user remote_dir
    local -A host_set=()
    local known_hosts=""
    for dir in "${autofs_dirs[@]}"; do
	local extra_opt=""
	case "$dir" in
	    bergenrabbit )
		host=bergenrabbit.net
		port=2022
		host_key_alias=bergenrabbit-www
		host_pubkey="$hippyru_www_pubkey"
		keyfile=hippyru-www
		remote_user=user
		remote_dir=/
		;;
	    hippyru )
		host=hippyru.net
		port=2022
		host_key_alias=hippyru-www
		host_pubkey="$hippyru_www_pubkey"
		keyfile=hippyru-www
		remote_user=user
		remote_dir=/
		;;
	    lubavainfo )
		host=lubava.info
		port=2022
		host_key_alias=lubavainfo-www
		host_pubkey="$hippyru_www_pubkey"
		keyfile=hippyru-www
		remote_user=user
		remote_dir=/
		;;
	    kino )
		host=media.mir2.org
		port=9092
		host_key_alias=kino
		host_pubkey="$media_pubkey"
		keyfile=
		remote_user=user
		remote_dir=/files
		extra_opt="ssh_command=$ssh_kino_wrap"
		extra_opt+=",max_readahead=1048576"
		;;
	    dzetacon )
		host=thip
		port=3022
		host_key_alias=dzetacon
		host_pubkey="$dzetacon_pubkey"
		keyfile=dzetacon
		remote_user=user
		remote_dir=/home/user
		;;
	    * ) err "$dir"
	esac

	known_hosts+="$host_key_alias $host_pubkey$NL"

	host_set[$host]=1

	local local_user
	case "$NAME" in
	    miranda ) local_user=igor ;;
	    ultrabook ) local_user=lubava ;;
	    untrusted ) local_user=user ;;
	esac

	local opt=""
	opt+="rw,nodev,nosuid,noatime,allow_other,nonempty"
	opt+=",max_read=65536,reconnect,intr"
	opt+=",workaround=all,transform_symlinks,follow_symlinks"
	opt+=",ServerAliveInterval=5,ServerAliveCountMax=2"
	opt+=",CheckHostIP=no"
	opt+=",Port=$port"
	opt+=",Ciphers=aes128-gcm@openssh.com"
	opt+=",MACs=umac-128@openssh.com"
	opt+=",StrictHostKeyChecking=yes"
	opt+=",HostKeyAlias=$host_key_alias"
	opt+=",UserKnownHostsFile=$gen_config/sshfs_known_hosts"
	opt+=",ControlPath=none"
	if [[ $keyfile ]]; then
	    local ssh_key_file=
	    ensure_root_ssh_key "$keyfile"
	    opt+=",IdentityFile=$ssh_key_file"
	fi
	opt+=",uid=$(id -u "$local_user"),gid=$(id -g "$local_user")"
	opt+="${extra_opt:+,}$extra_opt"

	local mount_dir="$gen_mount/$dir"
	local unitname="$(systemd-escape -p "$mount_dir")"
	p_file "service:$unitname.mount" "\
[Mount]
Where=$mount_dir
Type=fuse.sshfs
What=$remote_user@$host:$remote_dir
Options=$opt
"
	# Using TimeoutIdleSec leads to a hung after network is
	# recovered after first successful mount.
	p_file "service:$unitname.automount" "\
[Automount]
Where=$mount_dir
#TimeoutIdleSec=30
"
        multi_user_wants+=("$unitname.automount")
    done

    p_nl
    p_file config:sshfs_known_hosts "$known_hosts"

    if [[ ! -h /set || "$(readlink /set)" != "$gen_mount" ]]; then
	cmd_log rm -f /set
	cmd_log ln -s "$gen_mount" /set
    fi
}

setup_hippyru_backup() {
    [[ $hippyru_backup_time || $NAME == thip ]] || return 0

    local ssh_key_file=
    ensure_root_ssh_key hippyru-www-backup

    if [[ $NAME == thip ]]; then
	return 0
    fi

    [[ $hippyru_backup_time =~ ^[0-2][0-9]:[0-5][0-9]:[0-5][0-9]$ ]] || \
	err "Invalid backup time spec in hippyru_backup_time - '$hippyru_backup_time'"

    p_file service:tliset-hippyru-backup.timer "\
[Unit]
After=network-online.target
Wants=network-online.target

[Timer]
Persistent=true
OnCalendar=$hippyru_backup_time
"
    p_file service:tliset-hippyru-backup.service "\
[Unit]
After=network-online.target
Wants=network-online.target

[Service]
ExecStart=/bin/bash $gen_scripts/hippyru-backup.bash
StandardError=journal
StandardOutput=journal
Type=oneshot
"
    multi_user_wants+=("tliset-hippyru-backup.timer")

    # Script source with condition code
    local s='#!/usr/bin/bash
set -e -u -o pipefail

# Number of days to keep old backups in the changed dir
max_keep_changed_days=60

'
    # On fedora change SELinux context for rsync so it is treated as
    # a binary. As an update can reset it, do it each time before running
    # rsync.
    if let kind_fedora; then
	s+='
se_context=$(stat -c %C /usr/bin/rsync)
if [[ $se_context =~ ^[^:]*:[^:]*:([^:]*):[^:]*$ ]]; then
    if [[ ${BASH_REMATCH[1]} != bin_t ]]; then
        echo "Changing SE context for /usr/bin/rsync from ${BASH_REMATCH[1]} to bin_t" 1>&2
        chcon -t bin_t /usr/bin/rsync
    fi
fi
'
    fi
    s+='

readonly backup_root="/area/backup"

remove_list=()

backup_from_host() {
    local pod_name="$1" host_name="$2"
    local data="$backup_root/$pod_name"
    local changes="$backup_root/changes/$pod_name"
    local partial="$backup_root/rsync-partial/$pod_name"
    local dir
    for dir in "$data" "$changes" "$partial"; do
        if [[ ! -d "$dir" ]]; then
            mkdir -p "$dir"
        fi
    done

    local -a ssh_cmd=(
        ssh -l backup -p 2022 -i ~/.ssh/hippyru-www-backup-ed25519
        -o Ciphers=aes128-gcm@openssh.com
        -o StrictHostKeyChecking=no
    )

    local -a rsync_args=(
        -rlpt
        --no-owner --no-group --omit-dir-times --omit-link-times
        --partial-dir="$partial" --delete-after
        --info=NAME
        --rsh="${ssh_cmd[*]}"
    )

    local too_old_backup="$changes/$(date --date="-20 days" +%Y-%m-%d)"
    rm -rf "$too_old_backup"
    local changed_files
    changed_files="$changes/$(date +%Y-%m-%d)"
    echo "Backing up $pod_name" >&2
    local ok=1
    rsync "${rsync_args[@]}" --backup --backup-dir="$changed_files" \
        "rsync://$host_name/adata/" "$data/adata/" || ok=
    if [[ $ok ]]; then
	local i cur_time
	cur_time="$(date +%s)"
	for i in "$changes"/20[0-9][0-9]-[0-9][0-9]-[0-9][0-9]; do
	    dir_time="$(date --date="${i##*/}" +%s)"
	    if test "$((cur_time-dir_time))" -gt "$((max_keep_changed_days*86400))"; then
		remove_list+=("$i")
	    fi
	done
    fi

}

echo "Backing up hippyru-dock source"
src_top="$backup_root/src"
if [[ ! -d $src_top ]]; then
    mkdir "$src_top"
fi

src_dir="$src_top/hippyru-dock"
if [[ ! -d $src_dir ]]; then
    git clone https://github.com/ibukanov/hippyru-dock "$src_dir"
else
    (cd "$src_dir" && git pull)
fi

backup_from_host hippyru hippyru.net
backup_from_host bergenrabbit bergenrabbit.net
backup_from_host lubavainfo lubava.info

if [[ ${#remove_list[@]} -ne 0 ]]; then
    printf -v s "\\n\\t%s" "${remove_list[@]}"
    echo "removing older changes created more than $max_keep_changed_days days ago:$s"
    rm -rf "${remove_list[@]}"
fi

'

    p_file scripts:hippyru-backup.bash "$s"

    if let kind_fedora; then
	setsebool rsync_client 1
    fi
}

setup_sshd() {
    log "Checking sshd"
    inc_log_level

    if [[ $single_ssh_user ]]; then
	eval "local f=~$single_ssh_user/.ssh/authorized_keys"
	if [[ ! -s $f ]]; then
	    touch "$f"
	    chmod 600 "$f"
	    chown "$single_ssh_user:$single_ssh_user" "$f"
	    err "$f does not exist or empty." \
		"Add a public key there for $NAME access and try again."
	fi
    else
	local f=/etc/ssh/authorized_keys/root
	if [[ ! -e "$f" ]]; then
	    touch "$f"
	    chmod 640 "$f"
	fi
    fi

    if let sshd_extra_listen_port && let kind_fedora; then
	local re='^ssh_port_t\s\+tcp\s\+%s$'
	if ! semanage port -l -C | grep -q "$(printf "$re" "$sshd_extra_listen_port")"; then
	    cmd_log semanage port -a -t ssh_port_t -p tcp "$sshd_extra_listen_port"
	fi
    fi

    # Based on https://stribika.github.io/2015/01/04/secure-secure-shell.htlm
    local sshd_config="\
UsePrivilegeSeparation sandbox
PidFile none

KexAlgorithms curve25519-sha256@libssh.org,diffie-hellman-group-exchange-sha256
HostKey /etc/ssh/ssh_host_ed25519_key
Ciphers chacha20-poly1305@openssh.com,aes256-gcm@openssh.com,aes128-gcm@openssh.com
MACs hmac-sha2-512-etm@openssh.com,hmac-sha2-256-etm@openssh.com,hmac-ripemd160-etm@openssh.com,umac-128-etm@openssh.com,hmac-sha2-512,hmac-sha2-256,hmac-ripemd160,umac-128@openssh.com

UseDNS no
ClientAliveInterval 180

Subsystem sftp internal-sftp

PubkeyAuthentication yes
PasswordAuthentication no
ChallengeResponseAuthentication no
"
    if let kind_fedora || let kind_ubuntu; then
	sshd_config+="GSSAPIAuthentication no$NL"
	sshd_config+="UsePAM yes$NL"
	if [[ $NAME == ultrabook ]]; then
	    sshd_config+="X11Forwarding yes$NL"
	fi
    fi

    if [[ $single_ssh_user ]]; then
	sshd_config+="AllowUsers $single_ssh_user$NL"
    else
	sshd_config+="AuthorizedKeysFile /etc/ssh/authorized_keys/%u$NL"
    fi

    local sshd_config_path="/run/tliset/sshd_config"
    p_nl
    p_file config:sshd_config "$sshd_config"
    if let kind_fedora; then
	p_cmd chcon -t etc_t config:sshd_config
    fi

    if let kind_fedora || let kind_ubuntu; then
	local extra_sshd_options=""
	if let sshd_extra_listen_port; then
	    extra_sshd_options+=" -o Port=22 -o Port=$sshd_extra_listen_port"
	fi
	if let kind_fedora; then
	    local service_name=sshd
	else
	    local service_name=ssh
	fi
	p_dir "service:$service_name.service.d"
	p_file "service:$service_name.service.d/tliset.conf" "\
[Service]
Type=simple
PIDFile=
ExecStart=
ExecStart=/usr/sbin/sshd -D -e -f $gen_config/sshd_config$extra_sshd_options
"
    elif let kind_coreos; then
	if let sshd_extra_listen_port; then
	    p_dir service:sshd.socket.d
	    p_file service:sshd.socket.d/tliset.conf "\
[Socket]
ListenStream=$sshd_extra_listen_port
"
	fi
	p_dir service:sshd@.service.d
	p_file service:sshd@.service.d/tliset.conf "\
[Service]
Environment=\"OPTIONS=-f $sshd_config_path\"
"
    fi

    if let with_enabled_sshd; then
	# On coreos this is enabled by default
	if let kind_fedora || let kind_ubuntu; then
	    multi_user_wants+=(sshd.service)
	fi
    else
	if systemctl -q is-enabled sshd; then
	    log "disabling sshd"
	    systemctl disable sshd
	fi
    fi

    dec_log_level
}

add_user() {
    local user="$1" id="$2"
    if ! id -u "$user" 2>/dev/null 1>&2; then
	log "creating user name=$user id=$id"
	groupadd -g "$id" "$user"
	useradd -g "$id" -u "$id" "$user"
	passwd -d "$user"
    fi
}

setup_users() {
    log "Checking users"
    inc_log_level
    if [[ "$NAME" == ultrabook || "$NAME" == miranda ]]; then
	add_user lubava 1978
    fi
    if [[ "$NAME" == miranda ]]; then
	add_user igor 1973
	if ! getent group vboxsf >/dev/null ; then
	    cmd_log usermod -a -G vboxsf igor
	fi
    fi
    dec_log_level
}

setup_services() {
    log "Checking services"
    inc_log_level

    setup_net_mounts

    setup_hippyru_backup

    if let kind_fedora; then
	p_mask_service docker.service
    fi

    if let kind_coreos; then
	# Ignore system and user configs
	#p_mask_service system-cloudinit@.service
	#p_mask_service user-cloudinit@.service

	# On CoreOS docker is socket-activated by default which breaks
	# restarting containers on boot unless a docker client runs
	multi_user_wants+=(docker.service)
    fi

    if let with_vol_storage; then
	p_file scripts:mount-vol.sh "$(cat <<'EOF'
#!/bin/sh
set -e -u
mkdir -p /vol
root_mount="$(grep ' / ' /proc/mounts)"
root_device_prefix="${root_mount%%[0-9]*}"
case "$root_device_prefix" in
    /dev/sda ) device=/dev/sdb ;;
    /dev/vda ) device=/dev/vdb ;;
    * ) echo "Cannot deduce storage device, root_device_prefix='$root_device_prefix' root_mount='$root_mount'" 1>&2; exit 1 ;;
esac

test -b "$device" || { echo "No extra storage" 1>&2; exit 0; }
if ! grep -q "^$device\>" /proc/mounts && ! mount -t ext4 "$device" /vol 2>/dev/null; then
    set -x
    mkfs.ext4 "$device"
    mount -t ext4 "$device" /vol
    set +x
fi
if [[ ! -d /vol/src ]]; then
    set -x
    tmp="$(mktemp -d -p /vol)"
    chmod 755 "$tmp" && chown core:core "$tmp" && mv "$tmp" /vol/src || \
        { rmdir "$tmp"; exit 1; }
    set +x
fi
if [[ ! -d /vol/docker ]]; then
    mkdir -m 755 /vol/docker
fi
mount --bind /vol/docker /var/lib/docker
EOF
)"
	p_file service:tliset-mount-vol.service "\
[Unit]
Before=docker.service
[Service]
Type=oneshot
ExecStart=/bin/sh $gen_scripts/mount-vol.sh
"
	multi_user_wants+=(tliset-mount-vol.service)
    fi

    dec_log_level
}

setup_files() {
    if let kind_coreos; then
	case $NAME in
	    bergenrabbit | hippyru | lubavainfo  )
		ensure_dir /opt /opt/dpodctl "/opt/dpodctl/$NAME"
		write_file "/opt/dpodctl/$NAME/config.dpod" "\
ImageName $NAME
"
		;;
	    thip ) setup_thip_files ;;
	esac
    fi
}

setup_thip_files() {
    if [[ ! -d /vol/src ]]; then
	log "/vol/src does not exist, rerun after it is mounted"
    fi

    local dir="/vol/src/build-dpod"
    ensure_dir "$dir"
    local i j=0

    # HostEnv lines for browser-thip with IP addresses of
    # hippyru-related hosts.
    local browser_thip_host_config=""

    local -a virt_net_ids=()
    add_virt_net_ids

    # The order of services must match ip address usage.
    for i in hippyru bergenrabbit lubavainfo transdock dzetacon browser-thip; do
	ensure_dir "$dir/$i"
	if [[ $j -lt ${#virt_net_ids[@]} ]]; then
	    local ipv4="$virt_net_ipv4_prefix.${virt_net_ids[$j]}"
	    : $((j+=1))
	else
	    local ipv4="$virt_net_ipv4_prefix.${virt_net_ids[0]}"
	fi
	local config="" uses_generator=1
	case $i in
	    transdock )
		config+="\
Include ../../$i/config.dpod
AddHost boulder-mysql 127.0.0.1
AddHost boulder-rabbitmq 127.0.0.1
AddHost boulder 127.0.0.1
AddHost test.media.mir2.org 127.0.0.1
HostEnv TLS_HOST test.media.mir2.org
HostEnv LETSENCRYPT_CA http://boulder:4000/directory
HostEnv LETSENCRYPT_LICENSE http://boulder:4001/terms/v1
BindAddress $ipv4
"
		;;
	    browser-thip )
		uses_generator=
		config+="\
IncludeBuildDir ../../hippyru-dock/tools/$i
BindAddress $ipv4
"
		config+="$browset_thip_host_config"
		;;
	    dzetacon )
		config+="\
Include ../../$i/config.dpod
"
		;;
	    * )
		browset_thip_host_config+="\
HostEnv ${i^^}_HOST $ipv4
"
		config+="\
Include ../../hippyru-dock/$i/config.dpod
BindAddress $ipv4
"
		;;
	esac
	write_file "$dir/$i/config.dpod" "$config"
	if [[ $uses_generator ]]; then
	    ensure_dir -u core -g core "$dir/$i/gen"
	fi
    done
}


. "$selfdir/zram-setup"

show_usage=""
NAME=""
remote=""

while getopts :hn:r: opt; do
    case "$opt" in
	h ) show_usage=1 ;;
	n )
	    NAME="$OPTARG"
	    is_valid_host_name "$NAME" || \
		usage_err "The value of -n argument '$NAME' is not a known host name."
	    ;;
	r )
	    remote="$OPTARG"
	    is_valid_host_name "$remote" || \
		usage_err "The value of -n argument '$remote' is not a known host name."
	    ;;
	* ) getopts_err "$opt" "${OPTARG-}";;
    esac
done

#[[ $# -eq $(($OPTIND - 1)) ]] || usage_err "Unexpected extra arguments: $@"
let OPTIND==1+$# || usage_err "Unexpected extra arguments: $@"

[[ -z "$remote" || -z "$NAME" ]] || usage_err "Only one of -n, -r can be given"

if [[ -n "$show_usage" ]]; then
    echo "Usage: $0 [OPTION]..."
    echo "Customize installation for the given computer."
    echo
    echo "  -h  show this help and exit"
    echo "  -n name  assume the given name as the hostname rather than use /etc/hostname."
    echo "           The valid values are (${valid_host_names[*]})."
    echo "  -r name  execute setup on the remote machine name using ssh to copy the setup files."
    echo
    exit
fi

if [[ -n "$remote" ]]; then
    NAME=$remote
elif [[ -z "$NAME" ]]; then
    IFS='' read NAME < /etc/hostname
    if ! is_valid_host_name "$NAME"; then
	err "The content of /etc/hostname is '$NAME' is not a supported name." \
	    "Use -n option to set the hostname explicitly."
    fi
fi

get_host_options

if [[ -n "$remote" ]]; then
    cmd=(run_remotely)
    if [[ -n "$single_ssh_user" ]]; then
	# Use sudo
	cmd+=(-s "$single_ssh_user@$remote")
    else
	cmd+=("root@$remote")
    fi
    "${cmd[@]}" -n "$remote"
fi

if [[ "$(id -u)" -ne 0 ]]; then
    exec sudo "$0" "$@"
fi

if [[ -f /etc/hostname ]]; then
    IFS='' read current_hostname < /etc/hostname
    if is_valid_host_name "$current_hostname" && [ "$NAME" != "$current_hostname" ]; then
	err "Already setup as $current_hostname. To force put localhost into /etc/hostname"
    fi
else
    echo "$NAME" > /etc/hostname
fi

virt="$(systemd-detect-virt -v || true)"
if [[ "$virt" == none ]]; then
    virt=""
fi

if [[ "$virt" == kvm ]]; then
    # systemd detects incorrectly
    if lspci | grep -q VirtualBox; then
	virt=oracle
    fi
fi

if [[ "$virt" == oracle ]]; then
    readonly with_virtual_box_network="1"
else
    readonly with_virtual_box_network="0"
fi

if let with_networkd_if_virt && [[ $virt ]]; then
    with_networkd=1
fi

if let kind_coreos && ! let with_enabled_sshd; then
    err "On CoreOS sshd must always be enabled"
fi

#if let kind_coreos; then
#    [[ ! -d /media/configdrive && ! -d /media/configvirtfs ]] || \
#	err "Cannot configure CoreOS that under cloudconfig control"
#fi

if let kind_fedora; then
    fedora_release="$(rpm -E %fedora)"
fi

start_generator_write

if [[ ! -d /var/lib/tliset ]]; then
    mkdir -p -m 755 /var/lib/tliset
fi

if let kind_fedora; then
    setup_fstab
fi
setup_packages
setup_grub
setup_sudo
if let with_zram; then
    setup_zram
fi
setup_sshd
setup_network
if let kind_fedora; then
    setup_users
fi
setup_services
setup_files

finish_generator_write
log "Done."
