#!/bin/bash

set -u
set -e
set -o pipefail
shopt -s lastpipe

readonly NL=$'\n'
selfdir="$(dirname "$0")"


valid_host_names=(bergenrabbit.net r2 r3.mir2.org r4.mir2.org rhea thip test-br)

kind_coreos=
kind_fedora=
kind_ubuntu=
kind_debian=

declare zram_size=
declare zram_algorithm=
declare -i with_zswap=0
declare -i with_latex=0
declare -i with_common_packages=0
declare -i with_include_rpmfusion=1

declare -i with_docker=0
declare -i with_sudoless_docker=0
declare -i with_docker_development_net=0
declare -i with_http_proxy=0
declare -i custom_user_watches_count=0

ssh_agent_service=

with_custom_sshd=
with_setuidless_sshd=

with_nginx=
tormed_host=

bergenrabbit_archive_time=
bergenrabbit_archive_root=

declare ssh_login_user=
declare machine_host=

# These 2 are deduced automatically
declare primary_user=

declare extra_system_users=()

declare -a explicit_ipv6=()

webserver_certificate_domains=

# Replace lables/uids with real devices in fstab/grub for security
# when allowing untrusted VM to access the whole disk.
declare -i with_disabled_disk_uuid=0

readonly dev_docker_network_prefix="192.168.96"
readonly dev_vz_network_prefix="192.168.97"

readonly gen_self_dir="/run/tliset"

bergenrabbit_dns="www.bergenrabbit.net bergenrabbit.net"
bergenrabbit_dns="${bergenrabbit_dns} www.bergenrabbit.no bergenrabbit.no"
bergenrabbit_dns="${bergenrabbit_dns} www.hippyru.net hippyru.net lib.hippyru.net"
bergenrabbit_dns="${bergenrabbit_dns} www.hippy.ru hippy.ru"
bergenrabbit_dns="${bergenrabbit_dns} www.lubava.info lubava.info"
bergenrabbit_dns="${bergenrabbit_dns} www.wmmsk.com wmmsk.com femicid.net"

get_host_options() {
    case "$NAME" in
	bergenrabbit.net )
	    zram_size=1024M
	    zram_algorithm=lz4
	    ;;
 	r2 )
	    bergenrabbit_archive_time=03:00:02
	    bergenrabbit_archive_root=/area/backup
	    explicit_ipv6=(2001:41d0:e:696::1/64 2001:41d0:e:6ff:ff:ff:ff:ff)
	    ssh_login_user=core
	    with_docker=1
	    zram_size=512M
	    ;;
 	r3.mir2.org | r4.mir2.org )
	    zram_size=8192M
	    zram_algorithm=lz4hc
	    with_custom_sshd=1
	    with_setuidless_sshd=1
	    with_nginx=1
	    if test r3.mir2.org = "${NAME}"; then
		enable_tormed media3.mir2.org
	    fi
	    if test r4.mir2.org = "${NAME}"; then
		bergenrabbit_archive_time=02:40:02
		bergenrabbit_archive_root=/data2/br-archive
	    fi
	    ;;
 	rhea )
	    with_common_packages=1
	    #with_docker=1
	    with_latex=1
	    zram_size=28G
	    zram_algorithm=lz4hc
	    #with_zswap=1

	    # disable until user namespaces works
	    #with_sudoless_docker=0
	    custom_user_watches_count="$((768*1025))"
	    ssh_agent_service=ssh-agent
	    ;;
	thip )
	    ssh_login_user=core
	    with_docker=1
	    with_docker_development_net=1
	    ;;
	test-br )
	    ssh_login_user=core
	    machine_host=thip
	    ;;
	* )
	    err "unknown '$NAME'"
	    ;;
    esac
}

err() {
    printf '%s:%d:%s: %s\n' "${BASH_SOURCE[0]}" "${BASH_LINENO[0]}" "${FUNCNAME[0]}" "$*" >&2
    exit 1
}

usage_err() {
    echo "$0: $@" 1>&2
    echo "Try $0 -h for usage" 1>&2
    exit 1
}

getopts_err() {
    local name=$1 optarg=$2 msg
    case "$name" in
	: ) msg="$-optarg requires an argument" ;;
	\? ) msg="unknown option -$optarg" ;;
	* ) msg="-$name is listed in getopts arguments but not processed" ;;
    esac
    if let "${#FUNCNAME[@]} <= 2"; then
	usage_err "$msg"
    else
	err "${FUNCNAME[1]} - $msg"
    fi
}

log_indent_level=0

log() {
    local indent='' i
    for ((i=0; i<log_indent_level; i+=1)); do
	indent+='  '
    done
    printf '%s%s\n' "$indent" "$*" 1>&2
}

cmd_log() {
    log "$*"
    "$@"
}

inc_log_level() {
    let log_indent_level+=1 || true
}

dec_log_level() {
    [[ $log_indent_level -ge 1 ]] || err "dec_log_level without inc_log_level"
    let log_indent_level-=1 || true
}

pl(){
    lines="${lines} $*${NL}"
}

determine_os() {
    local os_kind=
    if [[ -f /etc/os-release ]]; then
        local line
        {
            while IFS='' read -r line; do
                if [[ $line =~ ^ID=(.*)$ ]]; then
                    os_kind="${BASH_REMATCH[1]}"
                    break;
                fi
            done
        } < /etc/os-release
    fi

    case "${os_kind,,}" in
	coreos | "") kind_coreos=1 ;;
	debian ) kind_debian=1 ;;
	fedora ) kind_fedora=1 ;;
	ubuntu ) kind_ubuntu=1 ;;
	* ) err "Do not know how to determine OS, os_kind='$os_kind'" ;;
    esac
}

under_qubes() {
    if [[ ! -v under_qubes_flag ]]; then
	if [[ -d /etc/qubes ]]; then
	    declare -r -g under_qubes_flag=1
	else
	    declare -r -g under_qubes_flag=0
	fi
    fi
    let under_qubes_flag && return 0
    return 1
}

is_valid_host_name() {
    local name="$1" i
    for i in "${valid_host_names[@]}"; do
	if [[ "$i" == "$name" ]]; then
	    return 0
	fi
    done
    return 1;
}

ensure_dir() {
    local mode group user OPTIND opt dir
    mode=
    group=
    user=

    while getopts :g:m:u: opt; do
    case "$opt" in
    g ) group="$OPTARG";;
    m ) mode="$OPTARG";;
    u ) user="$OPTARG";;
    * ) err "bad ensure_dir usage";;
    esac
    done
    shift $(($OPTIND - 1))

    if test -z "${mode}"; then
	mode=0755
    fi
    if test -z "${user}"; then
	user=root
    fi
    if test -z "${group}"; then
	group="${user}"
    fi

    if test $# -eq 0; then
	return
    fi

    local dir
    for dir in "$@"; do
	test -n "${dir}" || err "directory cannot be empty"
	test "x${dir}" = "x${dir%/}" || err "directory must not end with slash - ${dir}"
	test "x${dir}" != "x${dir#/}" || err "directory must be an absolute path - ${dir}"
	if test ! -d "${dir}"; then
	    test ! -e "${dir}" -a ! -h "${dir}"  || err "${dir} exists and is not a directory"
	    cmd_log mkdir -m "${mode}" "${dir}"
	else
	    test ! -h "${dir}" || \
		err "$path exists and is a symbilic link, not a directory - ${dir}"
	fi
	local s
	s="$(find "${dir}" -maxdepth 0 -perm "${mode}" -user "${user}" -group "${group}" 2>/dev/null || :)"
	if test -z "${s}"; then
	    cmd_log chmod "=${mode}" "${dir}"
	    cmd_log chown "${user}:${group}" "${dir}"
	fi
	note_path "${dir}"
    done
}

ensure_symlink() {
    local target path
    target="$1"
    path="$2"
    file_update=
    while :; do
	if test -h "${path}"; then
	    local current_target
	    current_target="$(readlink "${path}")"
	    if test "x${current_target}" = "x${target}"; then
		break
	    fi
	elif test -d "${path}"; then
	    cmd_log rmdir "${path}" || \
		err "remove symbolic link ${path} manually and run again"
	fi
	cmd_log ln -sfT "${target}" "${path}"
	file_update=1
	break
    done
    note_path "${path}"
}

file_update=
file_update_count=0

write_file() {

    local user group mode OPTIND opt
    user=
    group=
    mode=
    while getopts :g:m:u: opt; do
	case "$opt" in
	g ) group="$OPTARG";;
	m ) mode="$OPTARG";;
	u ) user="$OPTARG";;
	* ) err "bad write_file usage";;
	esac
    done

    shift $((${OPTIND} - 1))
    test $# -eq 2 || err "write_file requires path and body arguments when $# arguments were given"

    local path body
    path="$1"
    body="$2"
    if test -z "${user}"; then
	user=root
    fi
    if test -z "${group}"; then
	group="${user}"
    fi
    if test -z "${mode}"; then
	mode=0644
    fi

    local wanted_umask need_chmod
    need_chmod=
    case "${mode}" in
    0644 ) wanted_umask=022 ;;
    0640 ) wanted_umask=027 ;;
    0600 ) wanted_umask=077 ;;
    0660 ) wanted_umask=007 ;;
    0755 ) wanted_umask=022 need_chmod=1 ;;
    * ) err "unsupported mode - ${mode}" ;;
    esac

    local do_update
    do_update=1
    while :; do
	if test ! -f "${path}" -o -h "${path}"; then
	    log "creating new ${path}"
	    break;
	fi
	local s
	s="$(find "$path" -maxdepth 0 -perm "$mode" -user "$user" -group "$group" -printf 1)"
	if test -z "${s}"; then
	    log "updating ${path} - permission changes"
	    break;
	fi

	if printf %s "${body}" | cmp -s "${path}" -; then
	    # Permissions and text matches
	    do_update=
	    break
	fi

	log "updating ${path} - content changes"
	break
    done

    if test -z "${do_update}"; then
	file_update=
    else
	# Use temporary to ensure atomic operation on filesystem
	local tmp
	tmp="${path}.tmp"
	if test -f "${tmp}"; then
	    rm "${tmp}"
	fi

	umask "${wanted_umask}"
	printf %s "${body}" > "${tmp}"
	if test -n "${need_chmod}"; then
	    chmod "${mode}" "${tmp}"
	fi
	chown "${user}:${group}" "${tmp}"
	mv -fT "${tmp}" "${path}"

	file_update=1
	: $((file_update_count+=1))
    fi
    note_path "${path}"
}

ensure_user() {
    local user home_path groups
    user="$1"
    home_path="$2"
    groups="${3-}"

    # TODO update HOME and groups on mismatch
    local s
    s="$(getent passwd "${user}" 2>/dev/null || :)"
    if test -z "${s}"; then
	set -- -M -d "${home_path}"
	if test -n "${groups}"; then
	    set -- "$@" -G "${groups}"
	fi
	cmd_log useradd "$@" "${user}"
    fi
}

ensure_group_member() {
    local group user
    group="$1"
    user="$2"
    file_update=
    local s
    s="$(getent group "${group}")"
    if test -z "${s}"; then
	err "group ${group} doesn't exist"
    fi
    s="${s##*:}"
    while test -n "${s}"; do
	local member
	member="${s%%,*}"
	if test "x${member}" = "x${user}"; then
	    break
	fi
	if test "x${member}" = "x${s}"; then
	    s=
	else
	    s="${s#*,}"
	fi
    done
    if test -z "${s}"; then
	cmd_log usermod -aG "${group}" "${user}"
	file_update=1
    fi
}

read_tliset_name() {
    R=''
    local path=/etc/tliset.name name
    if under_qubes; then
	path="/usr/local$path"
    fi
    [[ -s "$path" ]] || \
	err "$path does not exist or empty. Initilize it with a valid name and try again."
    IFS='' read -r name < "$path"
    local name_pattern='^[a-z0-9]+$'
    [[ $name =~ $name_pattern ]] || \
	err "$path content does not match $name_pattern - '$name'"
    R="$name"
}

enable_tormed() {
    local name
    name="$1"
    webserver_certificate_domains="${webserver_certificate_domains}${webserver_certificate_domains:+ }${name}"
    tormed_host="${name}"
}

add_dns_record_a() {
    local host ipv4
    host="$1"
    ipv4="$2"
    escape_for_shell "--host-record=${host},${ipv4}"
    extra_dnsmasq_eargs="${extra_dnsmasq_eargs} ${R}"
}

add_dns_interface_name() {
    local host interface
    host="$1"
    interface="$2"
    escape_for_shell "--interface-name=${host},${interface}"
    extra_dnsmasq_eargs="${extra_dnsmasq_eargs} ${R}"
}

fixup_transgui() {
    local path=/usr/share/applications/transgui.desktop
    local line='MimeType=application/x-bittorrent;x-scheme-handler/magnet;'
    if ! grep -q "^$line\$" "$path" ; then
	log "fixing $path"
	local data
	data="$(grep -v '^MimeType=' ${path})"
	printf '%s\n%s\n' "$data" "$line" > "${path}.tmp"
	chmod 644 "${path}.tmp"
	mv "${path}.tmp" "${path}"
    fi
}

begin_tliset() {
    paths_file=/var/lib/tliset/paths.txt
    can_note_paths=
    readonly paths_file
    ensure_dir /var/lib/tliset
    exec 9>>"${paths_file}.new"

    can_note_paths=1
    note_path /var/lib/tliset
    ensure_dir /usr/lib/tliset
}

end_tliset() {
    exec 9>&-
    local sorted
    sort "${paths_file}.new" > "${paths_file}.tmp"
    mv "${paths_file}.tmp" "${paths_file}.new"

    # Duplicates happens when tliset runs again after a failure
    uniq "${paths_file}.new" > "${paths_file}.tmp"
    mv "${paths_file}.tmp" "${paths_file}.new"

    if test -f "${paths_file}"; then
	comm -23 "${paths_file}" "${paths_file}.new" > "${paths_file}.unknown"
	filter_existing_paths < "${paths_file}.unknown" > "${paths_file}.tmp"
	mv "${paths_file}.tmp" "${paths_file}.unknown"
	if test -s "${paths_file}.unknown"; then
	    log "No longer generated files from the previous runs:" \
		"${NL}$(cat "${paths_file}.unknown")"
	fi
	sort "${paths_file}.new" "${paths_file}.unknown" > "${paths_file}.tmp"
	mv "${paths_file}.tmp" "${paths_file}.new"
    fi

    mv "${paths_file}.new" "${paths_file}"
}

filter_existing_paths() {
    local line
    while IFS= read -r line; do
	if test -e "${line}" -o -h "${line}"; then
	    printf '%s\n' "${line}"
	fi
    done
}

note_path() {
    local path
    path="$1"
    if test -n "${can_note_paths}"; then
	printf '%s\n' "${path}" 1>&9
    fi
}

setup_packages() {
    test -n "${kind_fedora}" -o -n "${kind_debian}" || return 0

    log "Checking packages"
    inc_log_level
    test -n "${kind_fedora}" && setup_fedora_packages
    test -n "${kind_debian}" && setup_debian_packages
    dec_log_level
    return 0
}


setup_fedora_packages() {
    if let with_common_packages && let with_include_rpmfusion; then
	local rpmfusion_kinds=(
	    free
	    nonfree
	)
	local i rpmfusion_repos=()
	for i in "${rpmfusion_kinds[@]}"; do
	    rpmfusion_repos+=("rpmfusion-$i-release")
	done

	if ! rpm -q --quiet "${rpmfusion_repos[@]}" ; then
	    log "Installing rpmfusion"
	    local urls=()
	    for i in "${rpmfusion_kinds[@]}"; do
		urls+=("http://download1.rpmfusion.org/$i/fedora/rpmfusion-$i-release-$fedora_release.noarch.rpm")
	    done
	    dnf install -y --nogpgcheck "${urls[@]}" || true
	fi
    fi
    local list=()
    if let with_common_packages; then
	list+=(
	    tmux terminus-fonts-console
	    git lsyncd
	    quilt mercurial subversion
	    livecd-tools
	    autoconf automake gcc-c++ kernel-devel chrpath
	    geany geany-plugins-spellcheck
	    tigervnc
	    pcp-system-tools strace
	    xclip xorg-x11-apps
	    xpra
	    xorg-x11-server-Xephyr
	    openssh-askpass

	    # filesystems
	    udftools inotify-tools fdupes fslint mtools

	    # encryption and backup
	    apg duplicity perl-Digest-Bcrypt lzip ccrypt pv

	    # Recovery tools
	    ddrescue foremost scalpel testdisk

	    # Graphs
	    graphviz graphviz-doc

	    # PDF tools
	    pdfmerge poppler-utils

	    # Media
	    gimp inkscape gthumb
	    scribus
	    evince evince-djvu pdf2djvu
	    linux-libertine-biolinum-fonts linux-libertine-fonts
	    gstreamer1-plugins-good-extras

	    # Languages
	    hunspell-ru hunspell-nb
	)

	if let with_include_rpmfusion; then
	    list+=(
		# Archives
		unrar libunrar

		# Media
		vlc
		kdenlive
		ffmpeg
		gstreamer1-libav
		gstreamer1-plugins-bad-free
		gstreamer1-plugins-bad-free-extras
		gstreamer1-plugins-bad-freeworld
		gstreamer1-plugins-ugly
	    )
	fi

	list+=(
	    # hardware management
	    util-linux lm_sensors
	)


	list+=(
	    gnome-tweaks
	    gnome-terminal-nautilus
	)
    fi

    let with_latex && list+=(
	    texlive
	    texlive-babel-norsk
	    texlive-hyphen-norwegian
	    texlive-babel-russian
	    texlive-collection-langcyrillic
	)

    list+=(gcc kernel-devel)

    if let with_docker; then
	list+=(
	    docker
	)
    fi

    if test rhea = "${NAME}"; then
	list+=(libguestfs-tools)
    fi

    for i in "${list[@]}"; do
	rpm -q --quiet "$i" || echo "Missed: $i"
    done

    if ! rpm -q --quiet "${list[@]}" ; then
	log "Installing missing packages"
	dnf install -y "${list[@]}"
    fi

    local remove_list=()

    if let ${#remove_list[@]}; then
	local status=0
	rpm -q --quiet "${remove_list[@]}" || status=$?
	if let "status < ${#remove_list[@]}"; then
	    cmd_log dnf remove -y "${remove_list[@]}"
	fi
	fixup_transgui
    fi

    write_file /etc/tmux.conf "new-session${NL}"
}

setup_debian_packages() {
    local eargs
    eargs=
    earg apt-file
    earg man-db
    earg lzip zip unzip
    earg ccrypt
    earg pv
    earg apg
    earg screen tmux
    earg git

    if test -n "${with_nginx}"; then
	earg nginx-full
	earg dehydrated ssl-cert
    fi
    if test -n "${tormed_host}"; then
	earg whois
	earg transmission-daemon
	earg jq

	# Make sure that the default transmission-daemon never starts
	ensure_symlink /dev/null /etc/systemd/system/transmission-daemon.service
	if test -n "${file_update}"; then
	    systemd_unit_update=1
	fi
    fi

    if let with_common_packages; then
	earg dstat
	earg libreoffice
	earg gvfs-bin
	earg libglib2.0-dev
	earg libgnome-keyring-dev
	earg ffmpeg
	earg firejail
	earg xpra
	earg xephyr
    fi

    if let with_latex; then
	earg texlive
	earg texlive-lang-cyrillic
	earg texlive-lang-european
    fi

    local escaped_install_list
    escaped_install_list="${eargs}"

    # Remove list

    eargs=
    earg resolvconf

    local escaped_remove_list
    escaped_remove_list="${eargs}"

    local escaped_apt_action_list
    escaped_apt_action_list=
    eval "fill_apt_action_list install ${escaped_install_list}"
    if test -n "${escaped_apt_action_list}"; then
	log "Installing missing packages"
	eval "DEBIAN_FRONTEND=noninteractive \
	    cmd_log apt-get install -y ${escaped_apt_action_list}"
    fi

    escaped_apt_action_list=
    eval "fill_apt_action_list uninstall ${escaped_remove_list}"
    if test -n "${escaped_apt_action_list}"; then
	log "Purging unnecessary packages ${remove_list[*]}"
	eval "DEBIAN_FRONTEND=noninteractive \
	    apt-get purge -y ${escaped_apt_action_list}"
    fi
}

fill_apt_action_list() {
    local action
    action="$1"
    shift
    test $# -ne 0 || return 0

    # Complication: for unknown packages dpkg-query reports an error,
    # so parse both stdout and stderr.
    local status_package_re
    status_package_re='^#stdout ([^ ]+)  ([^ ]+)$'
    local unknown_package_message_re
    unknown_package_message_re='^dpkg-query: no packages found matching ([^ ]+)$'
    local output
    output="$(dpkg-query -W --showformat \
	'#stdout ${db:Status-Abbrev} ${Package}\n' "$@"  2>&1 || :)"
    if test -n "${output}"; then
	local -a lines
	mapfile -t lines <<< "$output"
	local line
	for line in "${lines[@]}"; do
	    if [[ $line =~ $unknown_package_message_re ]]; then
		local package="${BASH_REMATCH[1]}"
		local status="unknown"
	    elif [[ $line =~ $status_package_re ]]; then
		local status="${BASH_REMATCH[1]}"
		local package="${BASH_REMATCH[2]}"
		case $status in
		    ii ) status=installed ;;
		    un ) status=uninstalled ;;
		    * ) err "unexpected dpkg-query status '$status': $line" ;;
		esac
	    else
		err "unexpected dpkg-query output: $line"
	    fi
	    if [[ $action == install ]]; then
		if [[ $status == installed ]]; then
		    continue
		fi
	    elif [[ $action == uninstall ]]; then
		# purge both installed packages and packages with config-files
		if [[ $status != installed && $status != config-files ]]; then
		    continue
		fi
	    else
		err "bad action: $action"
	    fi
	    escape_for_shell "$package"
	    escaped_apt_action_list="${escaped_apt_action_list} ${R}"
	done
    fi
}

# Set R to concatenation of arguments with spaces escaped if necessary.
escape_for_shell() {
    R=
    local arg
    for arg in "$@"; do
        case "${arg}" in
        "" | *[!A-Z0-9a-z_./-]* )
            local escaped before_quote
            escaped=
            while : ; do
                before_quote="${arg%%\'*}"
                if test "x${arg}" = "x${before_quote}"; then
                    break
                fi
                escaped="${escaped}${before_quote}'\\''"
                arg="${arg#*\'}"
            done
            arg="'$escaped$arg'"
            ;;
        esac
        R="${R}${R:+ }${arg}"
    done
}

earg() {
    escape_for_shell "$@"
    eargs="${eargs}${eargs:+ }$R"
}

start_generator_write() {
    multi_user_wants=()
    sockets_wants=()
    basic_target_wants=()
    systemd_unit_update=
    service_try_restart_list=
    service_restart_list=
    service_reload_list=
}

print_wants_list() {
    local target
    target="$1"
    shift
    test $# -ne 0 || return 0
    local i wants_body
    wants_body="[Unit]${NL}"
    for i in "$@"; do
	wants_body="${wants_body}Wants=${i}${NL}"
    done
    p_systemd_drop_in "${target}" "${wants_body}"
}

finish_generator_write() {
    print_wants_list multi-user.target "${multi_user_wants[@]:+${multi_user_wants[@]}}"
    print_wants_list sockets.target "${socket_wants[@]:+${socket_wants[@]}}"
    print_wants_list basic.target "${basic_target_wants[@]:+${basic_target_wants[@]}}"

    if test -n "${systemd_unit_update}"; then
	cmd_log systemctl daemon-reload
    fi
    if test -n "${service_restart_list}"; then
	eval "cmd_log systemctl restart${service_restart_list}"
    fi
    if test -n "${service_try_restart_list}"; then
	eval "cmd_log systemctl try-restart${service_try_restart_list}"
    fi
    if test -n "${service_reload_list}"; then
	eval "cmd_log systemctl reload${service_reload_list}"
    fi
}

# The first argument is <kind>:<subpath> where kind specifies
# directory kind and subpath is a file path. The second argument is
# text that should be written into the file at that path. Option -x
# indicattes that file must be executable.
p_file() {
    local executable
    executable=
    case "$1" in
    -x ) shift; executable=1 ;;
    esac
    local file_kind_and_path body
    file_kind_and_path="$1"
    body="$2"
    local path
    convert_kind_path "${file_kind_and_path}"
    path="${R}"

    set --
    if test -n "${executable}"; then
	set -- "$@" -m 0755
    fi
    write_file "$@" "${path}" "${body}"
    if test -n "${file_update}"; then
	case "${file_kind_and_path}" in
	service:* ) systemd_unit_update=1 ;;
	esac
    fi
}

p_dir() {
    local dir
    dir="$1"
    convert_kind_path "${dir}"
    dir="${R}"
    ensure_dir "${dir}"
}

p_ensure_no_file() {
    local file
    file="$1"
    convert_kind_path "${file}"
    file="${R}"
    file_update=
    if test -f "${file}"; then
	cmd_log rm -f "${file}"
	file_update=1
    fi
}

p_ensure_no_dir() {
    local dir
    dir="$1"
    convert_kind_path "${dir}"
    dir="${R}"
    if test -d "${dir}"; then
	cmd_log rmdir "${file}"
    fi
}

p_symlink() {
    local target path
    target="$1"
    path="$2"
    convert_kind_path "${path}"
    path="${R}"
    ensure_symlink "${target}" "${path}"
}

p_systemd_drop_in() {
    local unit_name drop_in
    unit_name="$1"
    drop_in_text="$2"

    p_dir "service:${unit_name}.d"
    p_file "service:${unit_name}.d/tliset.conf" "${drop_in_text}"
}

convert_kind_path() {
    local file_kind_and_path file_kind file_path
    file_kind_and_path="$1"
    file_kind="${file_kind_and_path%%:*}:"
    file_path="${file_kind_and_path#*:}"
    if test "x${file_path}" = "x${file_kind_and_path}"; then
	err "the argument must start with <kind>: prefix - ${file_kind_and_path}"
    fi
    local dir
    case "$file_kind" in
    module: ) dir='/etc/modules-load.d' ;;
    net: ) dir='/etc/systemd/network' ;;
    nspawn: ) dir="/etc/systemd/nspawn" ;;
    nginx-site: ) dir="/etc/nginx/sites-enabled" ;;
    nginx-config: ) dir="/etc/nginx/conf.d" ;;
    service: ) dir='/etc/systemd/system' ;;
    scripts: ) dir="/usr/lib/tliset" ;;
    sysctl: ) dir="/etc/sysctl.d" ;;
    NetworkManager: ) dir="/etc/NetworkManager/conf.d" ;;
    * ) err "Unknown file kind - ${file_kind_and_path}" ;;
    esac
    ensure_dir "${dir}"

    if test -z "${file_path}"; then
	R="$dir"
	return 0
    fi
    case "${file_path}" in
	/* ) err "the path part must be a relative path: ${file_kind_and_path}" ;;
    esac
    R="${dir}/${file_path}"
}

p_mask_service() {
    p_symlink /dev/null "service:$1"
}

setup_kernel_parameters() {
    if let with_zswap; then
	local unit
	unit=tliset-zswap.service
	p_file "service:${unit}" '
[Service]
Type=oneshot
ExecStart=/bin/sh -c "cd /sys/module/zswap/parameters && printf 1 > enabled && printf 30 > max_pool_percent && printf z3fold > zpool"
ExecStop=/bin/sh -c "printf 0 > /sys/module/zswap/parameters/enabled"
RemainAfterExit=yes
'
	basic_target_wants+=("${unit}")
    fi
    setup_zram

    local sysctl
    sysctl=""
    if let custom_user_watches_count; then
	sysctl+="fs.inotify.max_user_watches=${custom_user_watches_count}${NL}"
    fi

    if test -n "${sysctl}"; then
	p_file sysctl:50-tliset.conf "${sysctl}"
    else
	p_ensure_no_file sysctl:50-tliset.conf
    fi
}

setup_zram() {
    [[ $zram_size ]] || return 0

    log "Checking zram"

    local alg_arg
    alg_arg=
    if test -n "${zram_algorithm}"; then
	alg_arg=" --algorithm ${zram_algorithm}"
    fi

    p_file module:tliset-zram.conf "\
zram
"

    p_file service:tliset-zram.service '
[Unit]
Description=Service enabling RAM compression using zRam

[Install]
WantedBy=multi-user.target

[Service]
Type=oneshot
Environment=SWAP_SIZE='"${zram_size}"'
EnvironmentFile=-/run/tliset-zram-state
ExecStart=/bin/sh -c '\''\
set -e -u; \
printf "" > /run/tliset-zram-state; \
device="$(zramctl --find --size "$${SWAP_SIZE}"'"${alg_arg}"')"; \
echo "ZRAM_DEVICE=$${device}" >> /run/tliset-zram-state; \
/sbin/mkswap "$${device}"; \
/sbin/swapon -p 100 "$${device}"; \
echo "AFTER_SWAPON=1" >> /run/tliset-zram-state; \
swappiness=; \
read swappiness < /sys/fs/cgroup/memory/memory.swappiness; \
echo "ORIGINAL_SWAPINESS=$${swappiness}" >> /run/tliset-zram-state; \
printf 100 > /sys/fs/cgroup/memory/memory.swappiness'\''

ExecStopPost=/bin/sh -c '\''\
test -n "$${ORIGINAL_SWAPINESS-}" && \
  printf %%s "$${ORIGINAL_SWAPINESS}" > /sys/fs/cgroup/memory/memory.swappiness; \
test -n "$${AFTER_SWAPON-}" && /sbin/swapoff "$${ZRAM_DEVICE}"; \
test -n "$${ZRAM_DEVICE-}" && zramctl --reset "$${ZRAM_DEVICE}"; \
rm /run/tliset-zram-state'\''

RemainAfterExit=yes
'
    multi_user_wants+=(tliset-zram.service)

}

setup_network() {
    log "Checking network"
    inc_log_level

    if [[ ${#explicit_ipv6[@]} -ne 0 ]]; then
	test -n "${kind_coreos}" || err "unsupported configuration"
	local ipv6_address="${explicit_ipv6[0]}"
	local ipv6_gateway="${explicit_ipv6[1]}"
	p_file net:zz-default.network "\
[Network]
DHCP=ipv4

Address=$ipv6_address
Gateway=$ipv6_gateway

[DHCP]
UseMTU=true
UseDomains=true
"
    fi

    if [[ ${NAME} == rhea ]]; then
	p_file NetworkManager:tliset.conf "\
[main]
dns=dnsmasq
rc-manager=symlink
"

	: || p_file "net:40-nspawn1.network" "\
[Match]
Name=*-nspawn1

[Network]
# Default to using a /24 prefix, giving up to 253 addresses per virtual network.
Address=${dev_vz_network_prefix}.1/24
LinkLocalAddressing=yes
#DHCPServer=yes
IPMasquerade=yes
LLDP=yes
EmitLLDP=customer-bridge
"
    fi

    dec_log_level
}

ensure_root_ssh_key() {
    local prefix=$1
    local file=/root/.ssh/$prefix-ed25519
    if [[ ! -s "$file" ]]; then
	cmd_log mkdir -p -m 0700 /root/.ssh
	cmd_log ssh-keygen -t ed25519 -N '' -f "$file"
    fi
    ssh_key_file="$file"
}

setup_bergenrabbit_archive() {
    [[ $bergenrabbit_archive_time ]] || return 0

    local ssh_key_file=
    ensure_root_ssh_key bergenrabbit-www-backup

    if [[ $bergenrabbit_archive_time == manual ]]; then
	return 0
    fi

    [[ $bergenrabbit_archive_time =~ ^[0-2][0-9]:[0-5][0-9]:[0-5][0-9]$ ]] || \
	err "Invalid backup time spec in bergenrabbit_archive_time - '${bergenrabbit_archive_time}'"

    ensure_user tliset-br-archive "${bergenrabbit_archive_root}"
    ensure_dir -m 0770 -g tliset-br-archive "${bergenrabbit_archive_root}"

    p_file service:tliset-br-archive.timer "\
[Unit]
After=network-online.target
Wants=network-online.target

[Timer]
Persistent=true
OnCalendar=${bergenrabbit_archive_time}
"
    p_file service:tliset-br-archive.service '
[Unit]
After=network-online.target
Wants=network-online.target

[Service]
User=tliset-br-archive
ExecStart=/usr/lib/tliset/br-archive
StandardError=journal
StandardOutput=journal
Type=oneshot

ReadWritePaths='"${bergenrabbit_archive_root}"'

NoNewPrivileges=yes
PrivateDevices=yes
PrivateTmp=yes
ProtectKernelTunables=yes
ProtectControlGroups=yes
ProtectSystem=strict
'
    multi_user_wants+=("tliset-br-archive.timer")

    # Script source with condition code
    local s
    s='#!/bin/bash
set -e -u -o pipefail

# Number of days to keep old backups in the changed dir
max_keep_changed_days=90

'
    # On fedora change SELinux context for rsync so it is treated as
    # a binary, not a service. As an update can reset it, do it each
    # time we are about to run it.
    if test -n "${kind_fedora}"; then
	s+='
se_context=$(stat -c %C /usr/bin/rsync)
if [[ $se_context =~ ^[^:]*:[^:]*:([^:]*):[^:]*$ ]]; then
    if [[ ${BASH_REMATCH[1]} != bin_t ]]; then
        echo "Changing SE context for /usr/bin/rsync from ${BASH_REMATCH[1]} to bin_t" 1>&2
        chcon -t bin_t /usr/bin/rsync
    fi
fi
'
    fi
    s+='

readonly backup_root="'"${bergenrabbit_archive_root}"'"

remove_list=()

backup_from_host() {
    local pod_name="$1" host_name="$2"
    local data="$backup_root/$pod_name"
    local changes="$backup_root/changes/$pod_name"
    local partial="$backup_root/rsync-partial/$pod_name"
    local dir
    for dir in "$data" "$changes" "$partial"; do
        if [[ ! -d "$dir" ]]; then
            mkdir -p "$dir"
        fi
    done

    local -a ssh_cmd=(
        ssh -l br-backup -i ~/.ssh/bergenrabbit-www-backup-ed25519
        -o Ciphers=aes128-gcm@openssh.com
        -o StrictHostKeyChecking=no
    )

    local -a rsync_args=(
        -rlpt
        --no-owner --no-group --omit-dir-times --omit-link-times
        --partial-dir="$partial" --delete-after
        --info=NAME
        --rsh="${ssh_cmd[*]}"
    )

    local too_old_backup="$changes/$(date --date="-20 days" +%Y-%m-%d)"
    rm -rf "$too_old_backup"
    local changed_files
    changed_files="$changes/$(date +%Y-%m-%d)"
    mkdir -p "${changed_files}.srv" "${changed_files}.opt"

    echo "Backing up $pod_name" >&2
    local ok=1
    rsync "${rsync_args[@]}" --backup --backup-dir="${changed_files}.srv" \
        "rsync://$host_name/srv/" "$data/srv/" || ok=
    rsync "${rsync_args[@]}" --backup --backup-dir="${changed_files}.opt" \
        "rsync://$host_name/opt/" "$data/opt/" || ok=
    if [[ $ok ]]; then
	local i cur_time
	cur_time="$(date +%s)"
	for i in "$changes"/20[0-9][0-9]-[0-9][0-9]-[0-9][0-9].*; do
	    local file_name
	    file_name="${i##*/}"
	    dir_time="$(date --date="${file_name%%.*}" +%s)"
	    if test "$((cur_time-dir_time))" -gt "$((max_keep_changed_days*86400))"; then
		remove_list+=("$i")
	    fi
	done
    fi

}

backup_from_host bergenrabbit bergenrabbit.net

if [[ ${#remove_list[@]} -ne 0 ]]; then
    printf -v s "\\n\\t%s" "${remove_list[@]}"
    echo "removing older changes created more than $max_keep_changed_days days ago:$s"
    rm -rf "${remove_list[@]}"
fi

'

    write_file -m 0755 "/usr/lib/tliset/br-archive" "${s}"

    if test -n "${kind_fedora}"; then
	setsebool rsync_client 1
    fi
}

setup_services() {
    log "Checking services"
    inc_log_level

    setup_bergenrabbit_archive

    if let with_docker; then
	# Make sure that docker starts. On CoreOS docker is
	# socket-activated by default which breaks restarting
	# containers on boot unless a docker client runs
	if ! under_qubes; then
	    multi_user_wants+=(docker.service)
	fi

	local docker_lib_dir=
	if under_qubes; then
	    docker_lib_dir=/rw/varlib/docker
	fi
	local docker_service_lines=()
	if [[ $docker_lib_dir ]]; then
	    local unit
	    unit="$(systemd-escape -p "/var/lib/docker").mount"
	    p_file "service:$unit" "\
[Mount]
Where=/var/lib/docker
Type=none
Options=bind
What=$docker_lib_dir
"
	    docker_service_lines+=(
		"[Unit]"
		"BindsTo=$unit"
		"After=$unit"
	    )
	fi

	if test -n "${kind_fedora}"; then
	    p_mask_service docker-storage-setup.service
	    local exec_start=(
		/usr/bin/dockerd-current
		--add-runtime oci=/usr/libexec/docker/docker-runc-current
		--default-runtime=oci
		--containerd /run/containerd.sock
		--exec-opt native.cgroupdriver=systemd
		--userland-proxy=false
		--log-driver=journald
		--storage-driver=overlay2
	    )
	    docker_service_lines+=(
		"[Service]"
		"ExecStart="
		"ExecStart=${exec_start[*]}"
	    )
	fi

	if [[ $NAME == r2 ]]; then
	    docker_service_lines+=(
		"[Service]"
		"Environment=DOCKER_OPTS=--userland-proxy=false"
		"[Unit]"
		"[]"
	    )

	fi

	if [[ ${#docker_service_lines[@]} -ne 0 ]]; then
	    local text
	    printf -v text '%s\n' "${docker_service_lines[@]}"
	    p_systemd_drop_in docker.service "$text"
	fi
    fi

    setup_ssh_service
    setup_nginx_service
    setup_tormed_service

    if test -n "${ssh_agent_service}"; then
	local primary_user
	primary_user="${SUDO_USER}"
	ensure_user "${ssh_agent_service}" "/home/${ssh_agent_service}"
	local d
	d="/home/${ssh_agent_service}/keys"
	if test ! -d "${d}"; then
	    log "directory for ssh keys does not exist - ${d}"
	else
	    if test -d "${d}/common"; then
		setup_ssh_agent_service '' "${d}/common"
	    fi
	    local set_dir
	    for set_dir in "${d}/set-"*; do
		if test -d "${set_dir}"; then
		    setup_ssh_agent_service "${set_dir##*/set-}" "${set_dir}"
		fi
	    done
	fi
    fi

    dec_log_level
}


setup_ssh_service() {

    test -n "${with_custom_sshd}" || return 0

    local sshd_config
    sshd_config="\

PasswordAuthentication no
ChallengeResponseAuthentication no
UsePAM yes

X11Forwarding yes
PrintMotd no

#AcceptEnv LANG LC_*

Subsystem	sftp	/usr/lib/openssh/sftp-server
"
    if test -n "${tormed_host}"; then
	sshd_config="${sshd_config}
Match User tormed-files
  ChrootDirectory /var/lib/tormed/files-root
  ForceCommand internal-sftp -u 0007
  AllowTcpForwarding local
  PermitOpen 127.0.0.1:9091 127.0.0.1:9093
  PasswordAuthentication yes
"
    fi

    write_file /etc/ssh/sshd_config "${sshd_config}"
    if test -n "${file_update}"; then
	escape_for_shell ssh.service
	service_reload_list="${service_reload_list} ${R}"
    fi

    if test -n "${with_setuidless_sshd}"; then
	local ssh_drop_in
	ssh_drop_in="\
[Service]
NoNewPrivileges=yes
"
	p_systemd_drop_in ssh.service "${ssh_drop_in}"
    fi
}

setup_nginx_service() {
    test -n "${with_nginx}" || return 0

    local reload_nginx
    reload_nginx=
    write_nginx_configs

    local nginx_cmd
    nginx_cmd="/usr/sbin/nginx"
    nginx_cmd="${nginx_cmd} -g '"
    nginx_cmd="${nginx_cmd} daemon on;"
    nginx_cmd="${nginx_cmd} master_process on;"
    nginx_cmd="${nginx_cmd} pid /run/nginx/nginx.pid;"
    nginx_cmd="${nginx_cmd}'"

    local unit_fragment
    unit_fragment='
[Service]
PIDFile=/run/nginx/nginx.pid
User=www-data
AmbientCapabilities=CAP_NET_BIND_SERVICE

Restart=on-failure
RestartSec=2s

ExecStartPre=
ExecStart=
ExecStart='"${nginx_cmd}"'
ExecStop=

KillSignal=SIGQUIT
ExecReload=
ExecReload=/bin/kill -s HUP $MAINPID

RuntimeDirectory=nginx
RuntimeDirectoryMode=0700
ReadWritePaths=/var/log/nginx /var/lib/nginx

NoNewPrivileges=yes
PrivateDevices=yes
PrivateTmp=yes
ProtectKernelTunables=yes
ProtectControlGroups=yes
ProtectSystem=strict
'

    p_systemd_drop_in nginx.service "${unit_fragment}"
    if test -n "${file_update}"; then
	escape_for_shell nginx.service
	service_try_restart_list="${service_try_restart_list} ${R}"
    elif test -n "${reload_nginx}"; then
	escape_for_shell nginx.service
	service_reload_list="${service_reload_list} ${R}"
    fi

    setup_letsencrypt
}

write_nginx_configs() {

    local s
    if grep -q '^user www-data;$' /etc/nginx/nginx.conf; then
	log "Patching /etc/nginx/nginx.conf"
	s='s/^\(user www-data\|worker_processes auto\|pid \/run\/nginx.pid\);/#&/g'
	sed -i -e "${s}" /etc/nginx/nginx.conf
	reload_nginx=1
    fi

    s=
    if test -n "${tormed_host}"; then
	s="${s}"'

limit_req_zone $binary_remote_addr zone=tormed:1m rate=5r/s;

upstream transmission {
	server 127.0.0.1:9091;
	keepalive 4;
}

upstream transmission2 {
	server 127.0.0.1:9093;
	keepalive 4;
}

server {
	server_name '"${tormed_host}"';
	listen 80;
	listen [::]:80;

	access_log off;

	location /.well-known/acme-challenge/ {
		alias /run/acme-challenge/;
	}
	location / {
		return 301 https://'"${tormed_host}"'$request_uri;
	}
}

server {
	server_name '"${tormed_host}"';
	listen 443 ssl http2;
	listen [::]:443 ssl http2;

	ssl_certificate /var/lib/dehydrated/certs/host/fullchain.pem;
	ssl_certificate_key /var/lib/dehydrated/certs/host/privkey.pem;
	ssl_protocols TLSv1.2;

	limit_req zone=tormed burst=25;
	access_log off;

	auth_basic "Restricted";
	auth_basic_user_file /etc/tormed/htpassword/htpassword;

	location / {
		root /usr/lib/tormed/www;
		try_files $uri $uri/ =404;
		index index.html index.htm;
	}

	location /files/ {
		alias /var/lib/tormed/files-root/files/;

		directio 4m;
		output_buffers 1 1m;

		dav_methods PUT DELETE MKCOL COPY MOVE;
		dav_access group:rw;

		# This is for directory listing
		dav_ext_methods PROPFIND OPTIONS;

		autoindex on;
		autoindex_exact_size off;
		autoindex_localtime on;
		charset utf-8;

		try_files $uri $uri/ =404;
	}

	# Serve static files from the Tranmission web interface itself
	location /transmission/web/ {
		alias /usr/share/transmission/web/;
		index index.html index.htm;
	}

	location /transmission2/web/ {
		alias /usr/share/transmission/web/;
		index index.html index.htm;
	}
	location /transmission/ {
		proxy_pass          http://transmission;
		proxy_http_version  1.1;
		proxy_redirect      off;
		proxy_buffering     off;
		proxy_set_header    Host            $host;
		proxy_set_header    X-Real-IP       $remote_addr;
		proxy_set_header    Connection      "";
		proxy_pass_header   X-Transmission-Session-Id;
	}

	location /transmission2/ {
		proxy_pass          http://transmission2/transmission/;
		proxy_http_version  1.1;
		proxy_redirect      off;
		proxy_buffering     off;
		proxy_set_header    Host            $host;
		proxy_set_header    X-Real-IP       $remote_addr;
		proxy_set_header    Connection      "";
		proxy_pass_header   X-Transmission-Session-Id;
	}
}
'
    fi

    if test -n "${s}"; then
	p_file "nginx-site:tliset" "${s}"
	if test -n "${file_update}"; then
	    reload_nginx=1
	fi
    fi

    p_ensure_no_file nginx-site:default
    if test -n "${file_update}"; then
	reload_nginx=1
    fi
}

setup_tormed_service() {
    test -n "${tormed_host}" || return 0

    ensure_dir /var/lib/tormed

    local home_path
    home_path="/var/lib/tormed/files-root/files"
    ensure_user tormed-files "${home_path}"
    ensure_dir /var/lib/tormed/files-root
    ensure_dir -m 02770 -g tormed-files "${home_path}"

    ensure_group_member tormed-files www-data
    if test -n "${file_update}"; then
	# Restart nginx so the process gets the group membership
	escape_for_shell nginx.service
	service_try_restart_list="${service_try_restart_list} ${R}"
    fi

    local short_user full_user
    for short_user in service service2; do
	full_user="tormed-${short_user}"
	home_path="/var/lib/tormed/${short_user}"
	ensure_user "${full_user}" "${home_path}" tormed-files
	ensure_dir -m 0700 -u "${full_user}" -g "${full_user}" "${home_path}"
    done

    ensure_dir /etc/tormed
    ensure_dir -m 0750 -g www-data "/etc/tormed/htpassword"

    ensure_dir /usr/lib/tormed
    ensure_dir /usr/lib/tormed/www

    write_file -m 0755 "/usr/lib/tormed/update-password" '#!/bin/sh
set -e -u

err() {
    printf "%s\\n" "$*" >&2
    exit 1
}

if :; then
    test -t 0 -a -t 1 || err "both stdin and stdout must be tty"
    stty_orig="$(stty -g)"
    stty -echo echonl
    IFS= read -r -p "Enter new tormed password: " password || :
    stty "${stty_orig}"
    if test -z "${password}"; then
	err "Password cannot be empty"
    fi
    stty -echo echonl
    IFS= read -r -p "Confirm password: " password2 || :
    stty "${stty_orig}"
    if test "x${password}" != "x${password2}"; then
	err "Passwords mismatches."
    fi
fi

salt="$(dd if=/dev/urandom bs=12 count=1 status=none | base64 -w0 | tr + .)"
test 16 -eq ${#salt} || \
    err "unexpected salt length ${#salt} when 16 was expected"

hash="$(printf %s "$password" | mkpasswd -s -m sha-512 -R 5000 -S "$salt")"
test 118 -eq ${#hash} || \
    err "unexpected password hash length ${#hash} when 118 was expected"

printf "%s:%s\\n" user "$hash" > /etc/tormed/htpassword/htpassword
chmod 644 /etc/tormed/htpassword/htpassword

usermod -p "${hash}" tormed-files
'

    write_file "/usr/lib/tormed/www/index.html" \
'<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
</head>
<body>
<h3><a href="files/">Files</a></h3>
<h3><a href="transmission/web/">Tranmission web interface</a></h3>
</body>
</html>
'

    for short_user in service service2; do
	full_user="tormed-${short_user}"
	home_path="/var/lib/tormed/${short_user}"
	service_name="${tliset-tormed-${short_user}}"
	p_file "service:${service_name}.service" '
[Service]
Type=simple
User='"${full_user}"'

Restart=on-failure

ExecStart=/usr/lib/tliset/tormed-start-transmission

WorkingDirectory='"${home_path}"'
ReadWritePaths='"${home_path}"' /var/lib/tormed/files-root/files
BindPaths=/var/lib/tormed/files-root/files:/files

NoNewPrivileges=yes
PrivateDevices=yes
PrivateTmp=yes
ProtectKernelTunables=yes
ProtectControlGroups=yes
ProtectSystem=strict
'
	multi_user_wants+=("service:${service_name}.service")
	escape_for_shell "${service_name}.service"
	service_restart_list="${service_restart_list} ${R}"
    done

    local start_source
    start_source="$(print_tormed_start_tranmission)"
    write_file -m 0755 "/usr/lib/tliset/tormed-start-transmission" "${start_source}"
}

print_tormed_start_tranmission() {
    cat <<'EOF'
#!/bin/sh

set -e -u

user="$(id -un)"
case "${user}" in
tormed-service )
    suffix=
    peer_port="25602"
    rpc_port="9091"
    ;;
tormed-service2 )
    suffix=2
    peer_port="51412"
    rpc_port="9093"
    ;;
esac

settings_file=settings.json

# Transmission only uses the umask for directories in the config dir.
# It uses the file mode 600 for the state management files and 660/770
# for downloaded files and directories.
umask 002

if test ! -s "${settings_file}"; then
    echo "Creating defaults tranmission options in ${settings_file}" >&2

    default_settings='{
    "blocklist-enabled": false,
    "download-dir": "/files",
    "incomplete-dir": "/files/incomplete'"${suffix}"'",
    "incomplete-dir-enabled": false,
    "encryption": 1,
    "max-peers-global": 200,
    "pex-enabled": 1,
    "port-forwarding-enabled": false,
    "ratio-limit": 2,
    "ratio-limit-enabled": true,
    "speed-limit-down": 2000,
    "speed-limit-down-enabled": true,
    "speed-limit-up": 500,
    "speed-limit-up-enabled": true,
    "umask": 2
}
'
    ( umask 077 && printf %s "${default_settings}" > "${settings_file}" )
fi

jq_filter='.
| .["peer-port"] = '"${peer_port}"'
| .["rpc-authentication-required"] = false
| .["rpc-bind-address"] = "127.0.0.1"
| .["rpc-enabled"] = true
| .["rpc-host-whitelist-enabled"] = false
| .["rpc-port"] = '"${rpc_port}"'
| .["rpc-username"] = ""
| .["rpc-password"] = ""
| .["rpc-whitelist-enabled"] = false
| .["umask"] = 7
'

settings="$(jq "${jq_filter}" "${settings_file}")"
printf %s "${settings}" > "${settings_file}"

exec /usr/bin/transmission-daemon -f --log-error -g .
#exec /usr/bin/transmission-daemon -f --log-debug -g .
EOF

}

setup_letsencrypt() {
    test -n "${webserver_certificate_domains}" || return 0

    ensure_dir /var/lib/dehydrated
    ensure_dir -g www-data -m 0770 /var/lib/dehydrated/accounts
    ensure_dir -g www-data -m 0770 /var/lib/dehydrated/certs
    ensure_dir -u www-data -g www-data -m 0755 /var/lib/dehydrated/certs/host
    ensure_dir -g www-data -m 0770 /var/lib/dehydrated/state

    local cert_dir
    cert_dir="/var/lib/dehydrated/certs/host"
    if test ! -s "${cert_dir}/fullchain.pem" ; then
	cmd_log cp /etc/ssl/private/ssl-cert-snakeoil.key \
	    "${cert_dir}/privkey.pem"
	cmd_log cp /etc/ssl/certs/ssl-cert-snakeoil.pem \
	    "${cert_dir}/fullchain.pem.tmp"
	cmd_log chown www-data:www-data \
	    "${cert_dir}/privkey.pem" "${cert_dir}/fullchain.pem.tmp"
	cmd_log mv "${cert_dir}/fullchain.pem.tmp" "${cert_dir}/fullchain.pem"
    fi

    local s
    s='
CA=https://acme-v02.api.letsencrypt.org/directory
# Staging
#CA=https://acme-staging-v02.api.letsencrypt.org/directory
BASEDIR=/var/lib/dehydrated/state
DOMAINS_TXT="/etc/dehydrated/domains.txt"
WELLKNOWN=/run/acme-challenge
CERTDIR="/var/lib/dehydrated/certs"
ACCOUNTDIR="/var/lib/dehydrated/accounts"

# Workaround for a bug in older dehydrated
CURL_OPTS=--http1.1
'
    write_file /etc/dehydrated/config "${s}"
    write_file /etc/dehydrated/domains.txt \
	"${webserver_certificate_domains} > host"

    s='
set -e -u

dehydrated --account --accept-terms
dehydrated --cron --force
echo "sending NGINX signal to reload its config" >&2
read -r nginx_pid < /run/nginx/nginx.pid
kill -s HUP "${nginx_pid}"
echo "all OK" >&2
'

    write_file -m 0755 /usr/lib/tliset/dehydrated-renew "${s}"

    p_file service:tliset-dehydrated.service '
[Service]
Type=simple
User=www-data

Restart=on-failure

# Try twice a day until success
RestartSec=43200

ExecStart=/usr/lib/tliset/dehydrated-renew

RuntimeDirectory=acme-challenge
RuntimeDirectoryMode=0700
ReadWritePaths=/var/lib/dehydrated

NoNewPrivileges=yes
PrivateDevices=yes
PrivateTmp=yes
ProtectKernelTunables=yes
ProtectControlGroups=yes
ProtectSystem=strict
'

    p_file service:tliset-dehydrated.timer '
[Unit]
After=network-online.target
Wants=network-online.target

[Timer]
Persistent=true
OnCalendar=*-*-7 03:00:00
RandomizedDelaySec=86400
'
    if test -n "${file_update}"; then
	escape_for_shell tliset-dehydrated.timer
	service_restart_list="${service_restart_list} ${R}"
    fi
    multi_user_wants+=("service:tliset-dehydrated.timer")

}

setup_ssh_agent_service() {
    local key_set_name key_dir service_name sock_file
    key_set_name="$1"
    key_dir="$2"
    set -- "${key_dir}/"*_key
    if test ! -f "$1"; then
	log "directory for ssh keys has no *_key files - ${key_dir}"
	return
    fi
    service_name="tliset-${ssh_agent_service}"
    sock_file="common.sock"
    if test -n "${key_set_name}"; then
	service_name="${service_name}-${key_set_name}"
	sock_file="set-${key_set_name}.sock"
    fi

    # ssh-agent insists that the client must have the same user id as the agent
    # process. So use systemd-socket-proxyd both to support lazy loading and set
    # custom permissions on the socket file.
    p_file "service:${service_name}.socket" "\
[Socket]
ListenStream=/run/tliset-${ssh_agent_service}/${sock_file}
SocketUser=root
SocketGroup=${primary_user}
SocketMode=0660
"
    p_file "service:${service_name}.service" '
[Unit]
Requires='"${service_name}"'.socket
After='"${service_name}"'.socket

[Service]
ExecStart=/usr/bin/ssh-agent -a /tmp/agent.sock \
  sh -c '\''ssh-add "'"${key_dir}"'"/*_key < /dev/null > /dev/null && \
    exec /usr/lib/systemd/systemd-socket-proxyd /tmp/agent.sock'\''
PrivateTmp=yes
User='"${ssh_agent_service}"'
'
    multi_user_wants+=("${service_name}.socket")
}

setup_files() {
    case $NAME in
    r2 )
	ensure_dir /opt /opt/dpodctl "/opt/dpodctl/transdock"
	write_file "/opt/dpodctl/transdock/config.dpod" "\
ImageName local/transdock
HostEnv TLS_HOSTS media.mir2.org
HostEnv ACME_CONTACT mailto:igor@mir2.org
UseHostNetwork
"
	;;
    rhea )
	ensure_dir -m 0755 /vol
	;;
    thip )
	ensure_dir -m 0755 /vol
	ensure_dir -m 0770 -u root -g core /vol/projects
	;;
    esac

}

setup_accounts() {
    if let with_sudoless_docker; then
	if [[ -z ${SUDO_USER-} ]]; then
	    err "cannot determine the user for the docker command - SUDO_USER is not defined"
	fi
	local primary_user
	primary_user="${SUDO_USER}"
	local s
	s="$(getent group docker 2>/dev/null || :)"
	if [[ ! $s  ]]; then
	    cmd_log groupadd docker
	fi
	if ! [[ $s =~ ^[^:]+:[^:]*:[^:]+:(.*,)?"$primary_user"(,|$) ]]; then
	    cmd_log usermod -aG docker "$primary_user"
	fi
    fi
}

start_docker_container() {
    local container dockerfile run_args cmd_arg
    container="$1"
    dockerfile="$2"
    run_args="$3"
    cmd_args="${4-}"

    local image
    image="local/${container}"
    escape_for_shell "${image}"
    run_args="${run_args} ${R}${cmd_args:+ }${cmd_args}"

    local tag
    escape_for_shell "${dockerfile}"
    tag="$(printf '%s %s' "${R}" "${run_args}"| sha256sum)"
    tag="${tag%% *}"

    local s
    s="$(docker inspect --type container \
	-f  '{{.State.Running}} {{index .Config.Labels "local.tag"}}' \
	"${container}" 2>/dev/null || :)"

    local status current_tag
    status="${s%% *}"
    current_tag="${s#* }"
    if test true != "${status}" -o "x${current_tag}" != "x${tag}"; then
	log "Starting ${container} container"
	if test true = "${status}"; then
	    cmd_log docker stop "${container}" > /dev/null
	fi
	if test -n "${status}"; then
	    cmd_log docker rm -v "${container}" > /dev/null
	fi
	printf %s "${dockerfile}" | cmd_log docker build -t "${image}" -
	escape_for_shell cmd_log docker run -d --name "${container}" --label local.tag="${tag}"
	eval "${R} ${run_args} > /dev/null"
    fi
}

setup_docker_services() {
    let with_docker || return 0

    if ! docker version -f '{{.Server.Version}}' > /dev/null 2>&1; then
	log "Attempting to start the docker daemon"
	cmd_log systemctl start docker
    fi

    if let with_docker_development_net; then
	local net_name="development"
	local subnet_template
	subnet_template='{{range .IPAM.Config}}{{if .Subnet}}{{.Subnet}}{{end}}{{end}}'
	local subnet="${dev_docker_network_prefix}.0/24"
	local actual_subnet=
	docker network inspect -f "$subnet_template" "$net_name" 2> /dev/null \
	    | read -r actual_subnet || :
	if [[ $actual_subnet != "$subnet" ]]; then
	    log "Creating docker subnet $subnet"
	    if [[ $actual_subnet ]]; then
		cmd_log docker network rm "$net_name" > /dev/null
	    fi
	    local eargs
	    eargs=
	    earg --subnet="${subnet}"
	    earg --gateway="${dev_docker_network_prefix}.1"
	    earg "${net_name}"

	    eval "cmd_log docker network create ${eargs} > /dev/null"
	fi

	local extra_dnsmasq_eargs
	extra_dnsmasq_eargs=
	if test thip = "${NAME}"; then
	    setup_development_dpodctl
	fi

	if test thip = "${NAME}"; then

	    local host
	    for host in ${bergenrabbit_dns}; do
		add_dns_record_a "${host}" "${dev_vz_network_prefix}.100"
	    done
	    add_dns_record_a "boulder" "${dev_docker_network_prefix}.50"
	    #add_dns_interface_name "boulder" "eth0"

	    local container
	    container=dnsmasq
	    local dockerfile
	    IFS= read -r -d '' dockerfile <<EOF || :
FROM alpine:latest
RUN apk update && apk --no-cache add dnsmasq && rm -rf /var/cache/apk/*
EOF
	    local eargs
	    eargs=
	    earg --restart=unless-stopped
	    earg --net=host
	    earg --cap-add=NET_ADMIN
	    earg -v /run/systemd/resolve:/run/systemd/resolve

	    earg -v /dev/log:/dev/log
	    earg --log-driver=syslog
	    earg --log-opt syslog-facility=local1
	    earg --log-opt tag="${container}"

	    local docker_run_eargs
	    docker_run_eargs="${eargs}"

	    eargs=
	    earg -k
	    earg --no-resolv
	    #earg --resolv-file=/run/systemd/resolve/resolv.conf
	    earg --server=10.0.2.3
	    earg --localise-queries
	    earg --dhcp-range="${dev_vz_network_prefix}.100,${dev_vz_network_prefix}.199"
	    earg --dhcp-host="test-br,${dev_vz_network_prefix}.100"

	    eargs="${eargs}${extra_dnsmasq_eargs}"

	    start_docker_container "${container}" "${dockerfile}" \
		"${docker_run_eargs}" "dnsmasq ${eargs}"

	    write_file "/etc/resolv.conf" "nameserver 127.0.0.1${NL}"
	fi
    fi
}

setup_development_dpodctl() {
    local net_name="development"

    local dir="/opt/dpodctl"
    ensure_dir /opt/dpodctl

    local projects_root="/vol/projects"

    local i ip4_last_byte=10
    for i in transdock; do
	ensure_dir "$dir/$i"
	local ipv4="$dev_docker_network_prefix.$ip4_last_byte"
	: $((ip4_last_byte+=1))
	case $i in
	transdock )
	    add_dns_record_a media.mir2.org "${ipv4}"
	    add_dns_record_a test.media.mir2.org "${ipv4}"
	    write_file "$dir/$i/config.dpod" "\
IncludeBuild $projects_root/$i/config.dpod
DnsAlias media.mir2.org
DnsAlias test.media.mir2.org
HostEnv ACMELOOP_HOST 'media.mir2.org test.media.mir2.org'
HostEnv ACMELOOP_CA http://boulder:4000/directory
HostEnv ACMELOOP_CONTACT mailto:igor@mir2.org

HostEnv TLS_HOSTS 'media.mir2.org test.media.mir2.org'
HostEnv ACME_CA http://boulder:4000/directory
HostEnv ACME_CONTACT mailto:igor@mir2.org
BindAddress none
Network $net_name
NetworkIPv4 $ipv4
"
	    ;;
	esac
    done
}

run_remotely() {
    local OPTIND opt ssh_user machine_host
    ssh_user=root
    machine_host=
    while getopts :m:u: opt; do
	case "$opt" in
	m ) machine_host="${OPTARG}";;
	u ) ssh_user="${OPTARG}";;
	* ) getopts_err "$opt" "${OPTARG-}";;
	esac
    done
    shift $(($OPTIND - 1))

    local target_host="$1"
    shift

    # I need to send the directory and allow to use terminal to ask
    # for password or secreets. So just emebedd the archive into the
    # command as base64 and ensure that ssh allocates tty.
    local data=$(tar -C "${selfdir}" --exclude .git --exclude README.md --exclude LICENSE -cf - . | gzip -9 | base64 -w0)

    local i cmd
    cmd=$(printf %q "/tmp/tliset/$(basename "$0")")
    for i in "$@"; do
	cmd+=" $(printf %q "$i")"
    done

    local cmd="rm -rf /tmp/tliset && mkdir /tmp/tliset && printf %s $data | base64 -d | tar -C /tmp/tliset -xzf - && $cmd"

    local wrapped_cmd
    if [[ ${machine_host} ]]; then
	wrapped_cmd="systemd-run -M ${target_host} --quiet --tty --wait"
	wrapped_cmd+=" /bin/bash -c $(printf %q "$cmd")"
	if [[ ${ssh_user} != root ]]; then
	    wrapped_cmd="sudo ${wrapped_cmd}"
	fi
	target_host="${machine_host}"
    elif [[ ${ssh_user} != root ]]; then
	wrapped_cmd="sudo /bin/bash -c $(printf %q "$cmd")"
    else
	wrapped_cmd="${cmd}"
    fi
    exec ssh -t "${ssh_user}@${target_host}" "${wrapped_cmd}"
}


show_usage=""
NAME=""
remote=""

while getopts :hn:r:u: opt; do
    case "$opt" in
	h ) show_usage=1 ;;
	n )
	    NAME="$OPTARG"
	    is_valid_host_name "$NAME" || \
		usage_err "The value of -n argument '$NAME' is not a known host name."
	    ;;
	r )
	    remote="$OPTARG"
	    is_valid_host_name "$remote" || \
		usage_err "The value of -r argument '$remote' is not a known host name."
	    ;;
	* ) getopts_err "$opt" "${OPTARG-}";;
    esac
done

#[[ $# -eq $(($OPTIND - 1)) ]] || usage_err "Unexpected extra arguments: $@"
let OPTIND==1+$# || usage_err "Unexpected extra arguments: $@"

[[ -z "$remote" || -z "$NAME" ]] || usage_err "Only one of -n, -r can be given"

if [[ -n "$show_usage" ]]; then
    echo "Usage: $0 [OPTION]..."
    echo "Customize installation for the given computer."
    echo
    echo "  -h  show this help and exit"
    echo "  -n name  assume the given name as the hostname rather than use /etc/hostname."
    echo "           The valid values are (${valid_host_names[*]})."
    echo "  -r name  execute setup on the remote machine name using ssh to copy the setup files."
    echo
    exit
fi

if [[ $remote ]]; then
    NAME=$remote
elif [[ -z "$NAME" ]]; then
    read_tliset_name
    NAME="$R"
fi

get_host_options

if [[ -n "$remote" ]]; then
    cmd=(run_remotely)
    if [[ ${machine_host} ]]; then
	cmd+=(-m "${machine_host}")
    fi
    if [[ ${ssh_login_user} ]]; then
	cmd+=(-u "${ssh_login_user}")
    fi
    "${cmd[@]}" -- "$remote" -n "$remote"
fi

if [[ "$(id -u)" -ne 0 ]]; then
    exec sudo "$0" "$@"
fi

determine_os

if test -n "${kind_fedora}"; then
    fedora_release="$(rpm -E %fedora)"
fi

begin_tliset

start_generator_write

if ! under_qubes; then
    setup_packages
fi

setup_kernel_parameters
setup_network
setup_services
setup_files
setup_accounts

finish_generator_write

# Run services after the docker is configured
setup_docker_services

end_tliset

log "Done."
