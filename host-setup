#!/bin/bash

source "$(dirname "$0")/lib.bash"

#set -x

valid_host_names=(bergenrabbit r2 rhea thip test-br)

declare -i kind_coreos=0
declare -i kind_fedora=0
declare -i kind_ubuntu=0
declare -i kind_debian=0

declare zram_size=
declare -i with_zswap=0
declare -i with_latex=0
declare -i with_transgui=0
declare -i with_common_packages=0
declare -i with_include_rpmfusion=1

declare -i with_docker=0
declare -i with_sudoless_docker=0
declare -i with_docker_development_net=0
declare -i with_http_proxy=0

declare bergenrabbit_backup_time=

declare ssh_login_user=
declare machine_host=

# These 2 are deduced automatically
declare primary_user=

declare extra_system_users=()

declare -a explicit_ipv6=()

# Replace lables/uids with real devices in fstab/grub for security
# when allowing untrusted VM to access the whole disk.
declare -i with_disabled_disk_uuid=0

readonly dev_docker_network_prefix="192.168.96"
readonly dev_vz_network_prefix="192.168.97"

readonly gen_self_dir="/run/tliset"
readonly gen_scripts="$gen_self_dir"
readonly gen_config="$gen_self_dir"
readonly gen_mount="$gen_self_dir/set"

bergenrabbit_dns="www.bergenrabbit.net bergenrabbit.net"
bergenrabbit_dns="${bergenrabbit_dns} www.bergenrabbit.no bergenrabbit.no"
bergenrabbit_dns="${bergenrabbit_dns} www.hippyru.net hippyru.net lib.hippyru.net"
bergenrabbit_dns="${bergenrabbit_dns} www.hippy.ru hippy.ru"
bergenrabbit_dns="${bergenrabbit_dns} www.lubava.info lubava.info"

get_host_options() {
    case "$NAME" in
	bergenrabbit )
	    ssh_login_user=core
	    with_docker=1
	    zram_size=512M
	    ;;
 	r2 )
	    bergenrabbit_backup_time=03:00:02
	    explicit_ipv6=(2001:41d0:e:696::1/64 2001:41d0:e:6ff:ff:ff:ff:ff)
	    ssh_login_user=core
	    with_docker=1
	    zram_size=512M
	    ;;
 	rhea )
	    with_common_packages=1
	    with_docker=1
	    zram_size=8G

	    # disable until user namespaces works
	    with_sudoless_docker=0
	    ;;
	thip )
	    ssh_login_user=core
	    with_docker=1
	    with_docker_development_net=1
	    ;;
	test-br )
	    ssh_login_user=core
	    machine_host=thip
	    ;;
	* )
	    err "unknown '$NAME'"
	    ;;
    esac
}

determine_os() {
    local os_kind=
    if [[ -f /etc/os-release ]]; then
        local line
        {
            while IFS='' read -r line; do
                if [[ $line =~ ^ID=(.*)$ ]]; then
                    os_kind="${BASH_REMATCH[1]}"
                    break;
                fi
            done
        } < /etc/os-release
    fi

    case "${os_kind,,}" in
	coreos | "") kind_coreos=1 ;;
	debian ) kind_debian=1 ;;
	fedora ) kind_fedora=1 ;;
	ubuntu ) kind_ubuntu=1 ;;
	* ) err "Do not know how to determine OS, os_kind='$os_kind'" ;;
    esac
}

under_qubes() {
    if [[ ! -v under_qubes_flag ]]; then
	if [[ -d /etc/qubes ]]; then
	    declare -r -g under_qubes_flag=1
	else
	    declare -r -g under_qubes_flag=0
	fi
    fi
    let under_qubes_flag && return 0
    return 1
}

is_valid_host_name() {
    local name="$1" i
    for i in "${valid_host_names[@]}"; do
	if [[ "$i" == "$name" ]]; then
	    return 0
	fi
    done
    return 1;
}

read_tliset_name() {
    R=''
    local path=/etc/tliset.name name
    if under_qubes; then
	path="/usr/local$path"
    fi
    [[ -s "$path" ]] || \
	err "$path does not exist or empty. Initilize it with a valid name and try again."
    IFS='' read -r name < "$path"
    local name_pattern='^[a-z0-9]+$'
    [[ $name =~ $name_pattern ]] || \
	err "$path content does not match $name_pattern - '$name'"
    R="$name"
}

add_dns_record_a() {
    local host ipv4
    host="$1"
    ipv4="$2"
    escape_for_shell "--host-record=${host},${ipv4}"
    extra_dnsmasq_eargs="${extra_dnsmasq_eargs} ${R}"
}

add_dns_interface_name() {
    local host interface
    host="$1"
    interface="$2"
    escape_for_shell "--interface-name=${host},${interface}"
    extra_dnsmasq_eargs="${extra_dnsmasq_eargs} ${R}"
}

fixup_transgui() {
    local path=/usr/share/applications/transgui.desktop
    local line='MimeType=application/x-bittorrent;x-scheme-handler/magnet;'
    if ! grep -q "^$line\$" "$path" ; then
	log "fixing $path"
	local data="$(cat "$path" | grep -v '^MimeType=')"
	local tmp="$(mktemp "$path.XXXXXXXXXX")"
	tmp_files+=($tmp)
	printf '%s\n%s\n' "$data" "$line" > "$tmp"
	chmod 644 "$tmp"
	mv "$tmp" "$path"
    fi
}

note_path() {
    local path
    path="$1"
    printf '%s\n' "${path}" 1>&9
}

setup_tliset() {
    ensure_dir /var/lib/tliset
    exec 9>/var/lib/tliset/paths_new.txt
}

setup_packages() {
    let kind_fedora || let kind_ubuntu || return 0

    log "Checking packages"
    inc_log_level
    let kind_fedora && setup_fedora_packages
    let kind_ubuntu && setup_ubuntu_packages
    dec_log_level
    return 0
}


setup_fedora_packages() {
    if let with_common_packages && let with_include_rpmfusion; then
	local rpmfusion_kinds=(
	    free
	    nonfree
	)
	local i rpmfusion_repos=()
	for i in "${rpmfusion_kinds[@]}"; do
	    rpmfusion_repos+=("rpmfusion-$i-release")
	done

	if ! rpm -q --quiet "${rpmfusion_repos[@]}" ; then
	    log "Installing rpmfusion"
	    local urls=()
	    for i in "${rpmfusion_kinds[@]}"; do
		urls+=("http://download1.rpmfusion.org/$i/fedora/rpmfusion-$i-release-$fedora_release.noarch.rpm")
	    done
	    dnf install -y --nogpgcheck "${urls[@]}" || true
	fi
    fi
    local list=()
    if let with_common_packages; then
	list+=(
	    tmux
	    git lsyncd
	    quilt mercurial subversion
	    livecd-tools
	    autoconf automake gcc-c++ kernel-devel
	    geany geany-plugins-spellcheck
	    tigervnc
	    dstat strace
	    xclip xorg-x11-apps
	    xpra
	    xorg-x11-server-Xephyr
	    openssh-askpass

	    # filesystems
	    udftools inotify-tools fdupes fslint mtools

	    # encryption and backup
	    apg duplicity perl-Digest-Bcrypt python-gdata

	    # Recovery tools
	    ddrescue foremost scalpel testdisk

	    # Graphs
	    graphviz graphviz-doc

	    # PDF tools
	    pdfmerge poppler-utils

	    # Media
	    gimp inkscape gthumb
	    scribus
	    evince evince-djvu pdf2djvu
	    linux-libertine-biolinum-fonts linux-libertine-fonts
	    gstreamer1-plugins-good-extras

	    # Languages
	    hunspell-ru hunspell-nb
	)

	if let with_include_rpmfusion; then
	    list+=(
		# Archives
		unrar libunrar

		# Media
		vlc
		kdenlive
		ffmpeg
		gstreamer1-libav
		gstreamer1-plugins-bad-free
		gstreamer1-plugins-bad-free-extras
		gstreamer1-plugins-bad-freeworld
		gstreamer1-plugins-ugly
	    )
	fi

	list+=(
	    # hardware management
	    rfkill lm_sensors
	)


	list+=(
	    gnome-tweak-tool
	    gnome-terminal-nautilus
	    gnome-shell-extension-alternate-tab
	)
    fi

    let with_latex && list+=(
	    texlive
	    texlive-babel-norsk
	    texlive-babel-russian
	    texlive-collection-langcyrillic
	)
    let with_transgui && list+=(transgui openssl-devel)

    list+=(gcc kernel-devel)

    if let with_docker; then
	list+=(
	    docker
	)
    fi

    for i in "${list[@]}"; do
	rpm -q --quiet "$i" || echo "Missed: $i"
    done

    if ! rpm -q --quiet "${list[@]}" ; then
	log "Installing missing packages"
	dnf install -y "${list[@]}"
    fi

    local remove_list=()

    if let with_transgui; then
	remove_list+=(transmission-gtk transmission-remote-gtk)
    fi
    if let ${#remove_list[@]}; then
	local status=0
	rpm -q --quiet "${remove_list[@]}" || status=$?
	if let "status < ${#remove_list[@]}"; then
	    cmd_log dnf remove -y "${remove_list[@]}"
	fi
	fixup_transgui
    fi

    write_file /etc/tmux.conf "new-session${NL}"
}

setup_ubuntu_packages() {
    local -a install_list=() remove_list=()
    install_list+=(
	build-essential make-doc gcc g++ pkgconf
	git git-man liberror-perl
	emacs24 emacs24-el xterm xfonts-base
	xtightvncviewer xclip
	lsyncd apg apt-file libdigest-bcrypt-perl duplicity
    )

    if let with_common_packages; then
	install_list+=(
	    dstat
	    libreoffice
	    gvfs-bin
	    libglib2.0-dev
	    libgnome-keyring-dev
	    ffmpeg
	    firejail
	    xpra
	    xephyr
	)
    fi

    let with_transgui && install_list+=(transgui)
    remove_list+=(transmission-common)

    if let with_latex; then
	install_list+=(
	    texlive
	    texlive-lang-cyrillic
	    texlive-lang-european
	)
    fi

    remove_list+=(
	resolvconf
    )

    local -A package_status_map=()

    local -a apt_action_list=()
    fill_apt_action_list install "${install_list[@]:+${install_list[@]}}"
    if [[ ${#apt_action_list[@]} -ne 0 ]]; then
	log "Installing missing packages"
	DEBIAN_FRONTEND=noninteractive cmd_log apt-get install -y "${apt_action_list[@]}"
    fi

    local -a apt_action_list=()
    fill_apt_action_list uninstall "${remove_list[@]:+${remove_list[@]}}"
    if [[ ${#apt_action_list[@]} -ne 0 ]]; then
	log "Purging unnecessary packages ${remove_list[*]}"
	DEBIAN_FRONTEND=noninteractive apt-get purge -y "${apt_action_list[@]}"
    fi
}

fill_apt_action_list() {
    local action="$1"
    shift
    [[ $# -ne 0 ]] || return 0

    # Complication: for unknown packages dpkg-query reports an error,
    # so parse both stdout and stderr.
    local status_package_re='^#stdout ([^ ]+)  ([^ ]+)$'
    local unknown_package_message_re='^dpkg-query: no packages found matching ([^ ]+)$'
    local output
    output="$(dpkg-query -W --showformat '#stdout ${db:Status-Abbrev} ${Package}\n' "$@"  2>&1 || :)"
    if [[ $output ]]; then
	local -a lines
	mapfile -t lines <<< "$output"
	local line
	for line in "${lines[@]}"; do
	    if [[ $line =~ $unknown_package_message_re ]]; then
		local package="${BASH_REMATCH[1]}"
		local status="unknown"
	    elif [[ $line =~ $status_package_re ]]; then
		local status="${BASH_REMATCH[1]}"
		local package="${BASH_REMATCH[2]}"
		case $status in
		    ii ) status=installed ;;
		    un ) status=uninstalled ;;
		    * ) err "unexpected dpkg-query status '$status': $line" ;;
		esac
		package_status_map[$package]="$status"
	    else
		err "unexpected dpkg-query output: $line"
	    fi
	    if [[ $action == install ]]; then
		if [[ $status == installed ]]; then
		    continue
		fi
	    elif [[ $action == uninstall ]]; then
		# purge both installed packages and packages with config-files
		if [[ $status != installed && $status != config-files ]]; then
		    continue
		fi
	    else
		err "bad action: $action"
	    fi
	    apt_action_list+=("$package")
	done
    fi
}

# Set R to concatenation of arguments with spaces escaped if necessary.
escape_for_shell() {
    R=
    local arg
    for arg in "$@"; do
        case "${arg}" in
        *[!A-Z0-9a-z_./-]* )
            local escaped before_quote
            escaped=
            while : ; do
                before_quote="${arg%%\'*}"
                if test "x${arg}" = "x${before_quote}"; then
                    break
                fi
                escaped="${escaped}${before_quote}'\\''"
                arg="${arg#*\'}"
            done
            arg="'$escaped$arg'"
            ;;
        esac
        R="${R}${R:+ }${arg}"
    done
}

earg() {
    escape_for_shell "$@"
    eargs="${eargs}${eargs:+ }$R"
}

start_generator_write() {
    multi_user_wants=()
    sockets_wants=()
    basic_target_wants=()
    gen_body=()
    gen_mkdir_list=()
    with_nspawn_configs=
}

print_wants_list() {
    local target
    target="$1"
    shift
    test $# -ne 0 || return 0
    local i wants_body
    wants_body="[Unit]${NL}"
    for i in "$@"; do
	wants_body="${wants_body}Wants=${i}${NL}"
    done
    p_systemd_drop_in "${target}" "${wants_body}"
}

finish_generator_write() {
    if [[ ${with_nspawn_configs} ]]; then
	p_dir nspawn:
    fi
    p_dir scripts:
    print_wants_list multi-user.target "${multi_user_wants[@]:+${multi_user_wants[@]}}"
    print_wants_list sockets.target "${socket_wants[@]:+${socket_wants[@]}}"
    print_wants_list basic.target "${basic_target_wants[@]:+${basic_target_wants[@]}}"

    local script="\
#!/bin/sh

mkdir -p /run/tliset
exec > /run/tliset/log 2>&1

date '+%Y-%m-%d_%H:%M:%S'

set -x -u

mkdir -p ${gen_mkdir_list[*]}
"
    if [[ ${#gen_body[@]} -ne 0 ]]; then
	local gen_body_txt
	printf -v gen_body_txt '%s\n' "${gen_body[@]}"
	script+="$gen_body_txt"
    fi

    local dir="/etc/systemd/system-generators"
    if under_qubes; then
	ensure_dir "/usr/local"
	dir="/usr/local/etc"
    fi

    ensure_dir "${dir}"
    write_file -m 0755 "${dir}/tliset" "$script"
    if test -n "${file_update}"; then
	if under_qubes; then
	    "${dir}/tliset"
	fi
	cmd_log systemctl daemon-reload
    fi
}

p_add_raw() {
    gen_body+=("$1")
}

p_nl() {
    p_add_raw ''
}

# The first argument is <kind>:<subpath> where kind specifies
# directory kind and subpath is a file path. The second argument is
# text that should be written into the file at that path. Option -x
# indicattes that file must be executable.
p_file() {
    local executable
    executable=
    case "$1" in
    -x ) shift; executable=1 ;;
    esac
    local file_kind_and_path body
    file_kind_and_path="$1"
    body="$2"
    local path
    convert_shell_kind_path "${file_kind_and_path}"
    path="${R}"
    note_path "${path}"
    local escaped_path
    escape_for_shell "${path}"
    escaped_path="${R}"
    escape_for_shell "${body}"
    p_add_raw "> ${escaped_path} printf %s ${R}"
    if test -n "${executable}"; then
	p_add_raw "chmod 755 ${escaped_path}"
    fi
}

p_dir() {
    local dir
    dir="$1"
    convert_shell_kind_path "${dir}"
    dir="${R}"
    note_path "${dir}"
    escape_for_shell "${dir}"
    gen_mkdir_list+=("$R")
}

p_systemd_drop_in() {
    local unit_name drop_in
    unit_name="$1"
    drop_in_text="$2"

    p_nl
    p_dir "service:${unit_name}.d"
    p_file "service:${unit_name}.d/tliset.conf" "${drop_in_text}"
}

p_cmd() {
    local s="" arg
    for arg in "$@"; do
	if [[ $arg == *:* ]]; then
	    convert_shell_kind_path "$arg"
	    arg="${R}"
	fi
	escape_for_shell "$arg"
	s+="${s:+ }$R"
    done
    p_add_raw "$s"
}

convert_shell_kind_path() {
    local file_kind_and_path="$1"
    local file_kind="${file_kind_and_path%%:*}"
    [[ $file_kind != $file_kind_and_path ]] || err "the argument must start with <kind>: prefix"
    local file_path="${file_kind_and_path#*:}"
    local dir absolute=0
    case "$file_kind" in
    service ) dir='/run/systemd/system' ;;
    net ) dir='/run/systemd/network' ;;
    config ) dir="$gen_config" ;;
    mount ) dir="$gen_mount" ;;
    scripts ) dir="$gen_scripts" ;;
    top ) dir="" ; absolute=1 ;;
    nspawn )
	dir='/run/systemd/nspawn'
	with_nspawn_configs=1
	;;
    * ) err "Unknown dir_kind $dir_kind" ;;
    esac
    if let absolute; then
	[[ $file_path =~ ^/. ]] || err "$file_kind must come with absolute path: $file_kind_and_path"
    else
	if [[ $file_path == '' ]]; then
	    R="$dir"
	    return 0
	fi
	[[ $file_path =~ ^[^/] ]] || \
	    err "$file_kind must come with relative path: $file_kind_and_path"
	dir+="/"
    fi
    R="${dir}${file_path}"
}

p_mask_service() {
    p_cmd ln -s /dev/null "service:$1"
}

setup_kernel_parameters() {
    if let with_zswap; then
	p_add_raw 'printf 1 > /sys/module/zswap/parameters/enabled || :'
    fi
    setup_zram
}

setup_zram() {
    [[ $zram_size ]] || return 0

    log "Checking zram"

    p_nl
    p_file top:/run/tliset/zram-enable.sh '
set -e -u

SWAP_SIZE='"$zram_size"'

num_cpus=$(grep -c processor /proc/cpuinfo)
if [[ 0 = "$num_cpus" ]]; then
    num_cpus=1
fi

rm -f /run/tliset/zram-device
device="$(zramctl --find --size "$SWAP_SIZE" -t "$num_cpus")"
printf "%s\\n" "$device" > /run/tliset/zram-device

/sbin/mkswap "$device"
/sbin/swapon -p 100 "$device"
'

    p_nl
    p_file top:/run/tliset/zram-disable.sh "$(cat <<'EOF'
#!/bin/sh
set -e -u

device=
[[ -f /run/tliset/zram-device ]] || exit 0
read -r device < /run/tliset/zram-device || :
[[ $device ]] || exit 0
if grep -q "^$device\\s" /proc/swaps; then
    /sbin/swapoff "$device"
fi
zramctl --reset "$device"
rm /run/tliset/zram-device
EOF
)"

    p_nl
    p_file service:tliset-zram.service "\
[Unit]
Description=Service enabling RAM compression using zRam

[Install]
WantedBy=multi-user.target

[Service]
Type=oneshot
ExecStart=/sbin/modprobe zram num_devices=1
ExecStart=/bin/bash /run/tliset/zram-enable.sh
ExecStop=/bin/bash /run/tliset/zram-disable.sh
RemainAfterExit=yes
"
    multi_user_wants+=(tliset-zram.service)

}


setup_network() {
    log "Checking network"
    inc_log_level

    if [[ ${#explicit_ipv6[@]} -ne 0 ]]; then
	let kind_coreos || err "unsupported configuration"
	local ipv6_address="${explicit_ipv6[0]}"
	local ipv6_gateway="${explicit_ipv6[1]}"
	p_file net:zz-default.network "\
[Network]
DHCP=ipv4

Address=$ipv6_address
Gateway=$ipv6_gateway

[DHCP]
UseMTU=true
UseDomains=true
"
    fi

    if [[ ${NAME} == thip ]]; then
	write_file "/etc/systemd/network/40-nspawn1.network" "\
[Match]
Name=*-nspawn1

[Network]
# Default to using a /24 prefix, giving up to 253 addresses per virtual network.
Address=${dev_vz_network_prefix}.1/24
LinkLocalAddressing=yes
#DHCPServer=yes
IPMasquerade=yes
LLDP=yes
EmitLLDP=customer-bridge
"
    fi

    dec_log_level
}

ensure_root_ssh_key() {
    local prefix=$1
    local file=/root/.ssh/$prefix-ed25519
    if [[ ! -s "$file" ]]; then
	cmd_log mkdir -p -m 0700 /root/.ssh
	cmd_log ssh-keygen -t ed25519 -N '' -f "$file"
    fi
    ssh_key_file="$file"
}

setup_bergenrabbit_backup() {
    [[ $bergenrabbit_backup_time ]] || return 0

    local ssh_key_file=
    ensure_root_ssh_key bergenrabbit-www-backup

    if [[ $bergenrabbit_backup_time == manual ]]; then
	return 0
    fi

    [[ $bergenrabbit_backup_time =~ ^[0-2][0-9]:[0-5][0-9]:[0-5][0-9]$ ]] || \
	err "Invalid backup time spec in bergenrabbit_backup_time - '${bergenrabbit_backup_time}'"

    p_file service:tliset-bergenrabbit-backup.timer "\
[Unit]
After=network-online.target
Wants=network-online.target

[Timer]
Persistent=true
OnCalendar=${bergenrabbit_backup_time}
"
    p_file service:tliset-bergenrabbit-backup.service "\
[Unit]
After=network-online.target
Wants=network-online.target

[Service]
ExecStart=/bin/bash $gen_scripts/bergenrabbit-backup.bash
StandardError=journal
StandardOutput=journal
Type=oneshot
"
    multi_user_wants+=("tliset-bergenrabbit-backup.timer")

    # Script source with condition code
    local s='#!/usr/bin/bash
set -e -u -o pipefail

# Number of days to keep old backups in the changed dir
max_keep_changed_days=90

'
    # On fedora change SELinux context for rsync so it is treated as
    # a binary. As an update can reset it, do it each time before running
    # rsync.
    if let kind_fedora; then
	s+='
se_context=$(stat -c %C /usr/bin/rsync)
if [[ $se_context =~ ^[^:]*:[^:]*:([^:]*):[^:]*$ ]]; then
    if [[ ${BASH_REMATCH[1]} != bin_t ]]; then
        echo "Changing SE context for /usr/bin/rsync from ${BASH_REMATCH[1]} to bin_t" 1>&2
        chcon -t bin_t /usr/bin/rsync
    fi
fi
'
    fi
    s+='

readonly backup_root="/area/backup"

remove_list=()

backup_from_host() {
    local pod_name="$1" host_name="$2"
    local data="$backup_root/$pod_name"
    local changes="$backup_root/changes/$pod_name"
    local partial="$backup_root/rsync-partial/$pod_name"
    local dir
    for dir in "$data" "$changes" "$partial"; do
        if [[ ! -d "$dir" ]]; then
            mkdir -p "$dir"
        fi
    done

    local -a ssh_cmd=(
        ssh -l br-backup -i ~/.ssh/bergenrabbit-www-backup-ed25519
        -o Ciphers=aes128-gcm@openssh.com
        -o StrictHostKeyChecking=no
    )

    local -a rsync_args=(
        -rlpt
        --no-owner --no-group --omit-dir-times --omit-link-times
        --partial-dir="$partial" --delete-after
        --info=NAME
        --rsh="${ssh_cmd[*]}"
    )

    local too_old_backup="$changes/$(date --date="-20 days" +%Y-%m-%d)"
    rm -rf "$too_old_backup"
    local changed_files
    changed_files="$changes/$(date +%Y-%m-%d)"
    mkdir -p "${changed_files}.srv" "${changed_files}.opt"

    echo "Backing up $pod_name" >&2
    local ok=1
    rsync "${rsync_args[@]}" --backup --backup-dir="${changed_files}.srv" \
        "rsync://$host_name/srv/" "$data/srv/" || ok=
    rsync "${rsync_args[@]}" --backup --backup-dir="${changed_files}.opt" \
        "rsync://$host_name/opt/" "$data/opt/" || ok=
    if [[ $ok ]]; then
	local i cur_time
	cur_time="$(date +%s)"
	for i in "$changes"/20[0-9][0-9]-[0-9][0-9]-[0-9][0-9].*; do
	    local file_name
	    file_name="${i##*/}"
	    dir_time="$(date --date="${file_name%%.*}" +%s)"
	    if test "$((cur_time-dir_time))" -gt "$((max_keep_changed_days*86400))"; then
		remove_list+=("$i")
	    fi
	done
    fi

}

backup_from_host bergenrabbit bergenrabbit.net

if [[ ${#remove_list[@]} -ne 0 ]]; then
    printf -v s "\\n\\t%s" "${remove_list[@]}"
    echo "removing older changes created more than $max_keep_changed_days days ago:$s"
    rm -rf "${remove_list[@]}"
fi

'

    p_file scripts:bergenrabbit-backup.bash "$s"

    if let kind_fedora; then
	setsebool rsync_client 1
    fi
}

setup_services() {
    log "Checking services"
    inc_log_level

    setup_bergenrabbit_backup

    if let with_docker; then
	# Make sure that docker starts. On CoreOS docker is
	# socket-activated by default which breaks restarting
	# containers on boot unless a docker client runs
	if ! under_qubes; then
	    multi_user_wants+=(docker.service)
	fi

	local docker_lib_dir=
	if under_qubes; then
	    docker_lib_dir=/rw/varlib/docker
	fi
	local docker_service_lines=()
	if [[ $docker_lib_dir ]]; then
	    local unit
	    unit="$(systemd-escape -p "/var/lib/docker").mount"
	    p_nl
	    p_file "service:$unit" "\
[Mount]
Where=/var/lib/docker
Type=none
Options=bind
What=$docker_lib_dir
"
	    docker_service_lines+=(
		"[Unit]"
		"BindsTo=$unit"
		"After=$unit"
	    )
	fi

	if let kind_fedora; then
	    p_mask_service docker-storage-setup.service
	    local exec_start=(
		/usr/bin/dockerd-current
		--add-runtime oci=/usr/libexec/docker/docker-runc-current
		--default-runtime=oci
		--containerd /run/containerd.sock
		--exec-opt native.cgroupdriver=systemd
		--userland-proxy=false
		--log-driver=journald
		--storage-driver=overlay2
	    )
	    docker_service_lines+=(
		"[Service]"
		"ExecStart="
		"ExecStart=${exec_start[*]}"
	    )
	fi

	if [[ $NAME == r2 ]]; then
	    docker_service_lines+=(
		"[Service]"
		"Environment=DOCKER_OPTS=--userland-proxy=false"
		"[Unit]"
		"[]"
	    )

	fi

	if [[ ${#docker_service_lines[@]} -ne 0 ]]; then
	    local text
	    printf -v text '%s\n' "${docker_service_lines[@]}"
	    p_systemd_drop_in docker.service "$text"
	fi
    fi

    if [[ ${NAME} == thip ]]; then
	local unit
	unit="$(systemd-escape -p "/vol").mount"
	p_nl
	p_file "service:${unit}" "\
[Mount]
Where=/vol
What=/dev/vdb
Type=ext4
"
	basic_target_wants+=("${unit}")

	local mount_path
	mount_path=/run/projects
	local unit
	unit="$(systemd-escape -p "${mount_path}").mount"
	p_nl
	p_file "service:${unit}" "\
[Mount]
Where=${mount_path}
What=projects
Type=9p
Options=ro,access=client,trans=virtio
"
	basic_target_wants+=("${unit}")

    fi

    if [[ ${NAME} == thip ]]; then
	p_file nspawn:test-br.nspawn "\
[Exec]
Boot=on
#PrivateUsers=off

[Network]
Private=on
#VirtualEthernet=on
Port=tcp:2022:22
Port=tcp:8888:8888
#MACVLAN=eth0
Zone=nspawn1

[Files]
Bind=/vol/bergenrabbit/srv:/vol/srv
BindReadOnly=/run/projects/bergenrabbit:/vol/opt/2
Bind=+/vol/compiled:/vol/opt/2/compiled
"
	multi_user_wants+=(systemd-nspawn@test-br.service)

	# Prevent killing of containers after suspend
	p_systemd_drop_in systemd-machined.service "\
[Service]
WatchdogSec=0
"

	p_systemd_drop_in systemd-nspawn@test-br.service "\
[Service]
WatchdogSec=0
ExecStartPre=/run/projects/bergenrabbit/tools/prepare-test-br-machine
"
    fi

    dec_log_level
}

setup_files() {
    if let kind_coreos; then
	case $NAME in
	r2 )
	    ensure_dir /opt /opt/dpodctl "/opt/dpodctl/transdock"
	    write_file "/opt/dpodctl/transdock/config.dpod" "\
ImageName local/transdock
HostEnv TLS_HOSTS media.mir2.org
HostEnv ACME_CONTACT mailto:igor@mir2.org
UseHostNetwork
"
	    ;;
	thip )
	    ensure_dir -m 0755 /vol
	    ensure_dir -m 0750 /vol/bergenrabbit
	    local test_br_owner
	    test_br_owner="0:0"
	    if test -d /var/lib/machines/test-br; then
		test_br_owner="$(stat -c %u:%g /var/lib/machines/test-br)"
	    fi
	    local compiled_user compiled_group
	    compiled_user="${test_br_owner%%:*}"
	    compiled_group="${test_br_owner#*:}"
	    : $((compiled_group+=1005))
	    ensure_dir -m 0755 -u "${compiled_user}" -g "${compiled_group}" /vol/bergenrabbit/compiled
	    ;;
	esac
    fi
}

setup_accounts() {
    if let with_sudoless_docker; then
	if [[ -z ${SUDO_USER-} ]]; then
	    err "cannot determine the user for the docker command - SUDO_USER is not defined"
	fi
	local primary_user
	primary_user="${SUDO_USER}"
	local s
	s="$(getent group docker 2>/dev/null || :)"
	if [[ ! $s  ]]; then
	    cmd_log groupadd docker
	fi
	if ! [[ $s =~ ^[^:]+:[^:]*:[^:]+:(.*,)?"$primary_user"(,|$) ]]; then
	    cmd_log usermod -aG docker "$primary_user"
	fi
    fi
}

start_docker_container() {
    local container dockerfile run_args cmd_arg
    container="$1"
    dockerfile="$2"
    run_args="$3"
    cmd_args="${4-}"

    local image
    image="local/${container}"
    escape_for_shell "${image}"
    run_args="${run_args} ${R}${cmd_args:+ }${cmd_args}"

    local tag
    escape_for_shell "${dockerfile}"
    tag="$(printf '%s %s' "${R}" "${run_args}"| sha256sum)"
    tag="${tag%% *}"

    local s
    s="$(docker inspect --type container \
	-f  '{{.State.Running}} {{index .Config.Labels "local.tag"}}' \
	"${container}" 2>/dev/null || :)"

    local status current_tag
    status="${s%% *}"
    current_tag="${s#* }"
    if test true != "${status}" -o "x${current_tag}" != "x${tag}"; then
	log "Starting ${container} container"
	if test true = "${status}"; then
	    cmd_log docker stop "${container}" > /dev/null
	fi
	if test -n "${status}"; then
	    cmd_log docker rm -v "${container}" > /dev/null
	fi
	printf %s "${dockerfile}" | cmd_log docker build -t "${image}" -
	escape_for_shell cmd_log docker run -d --name "${container}" --label local.tag="${tag}"
	eval "${R} ${run_args} > /dev/null"
    fi
}

setup_docker_services() {
    let with_docker || return 0

    if ! docker version -f '{{.Server.Version}}' > /dev/null 2>&1; then
	log "Attempting to start the docker daemon"
	cmd_log systemctl start docker
    fi

    if let with_docker_development_net; then
	local net_name="development"
	local subnet_template
	subnet_template='{{range .IPAM.Config}}{{if .Subnet}}{{.Subnet}}{{end}}{{end}}'
	local subnet="${dev_docker_network_prefix}.0/24"
	local actual_subnet=
	docker network inspect -f "$subnet_template" "$net_name" 2> /dev/null \
	    | read -r actual_subnet || :
	if [[ $actual_subnet != "$subnet" ]]; then
	    log "Creating docker subnet $subnet"
	    if [[ $actual_subnet ]]; then
		cmd_log docker network rm "$net_name" > /dev/null
	    fi
	    local eargs
	    eargs=
	    earg --subnet="${subnet}"
	    earg --gateway="${dev_docker_network_prefix}.1"
	    earg "${net_name}"

	    eval "cmd_log docker network create ${eargs} > /dev/null"
	fi

	local extra_dnsmasq_eargs
	extra_dnsmasq_eargs=
	if test thip = "${NAME}"; then
	    setup_development_dpodctl
	fi

	if test thip = "${NAME}"; then

	    local host
	    for host in ${bergenrabbit_dns}; do
		add_dns_record_a "${host}" "${dev_vz_network_prefix}.100"
	    done
	    add_dns_record_a "boulder" "${dev_docker_network_prefix}.50"
	    #add_dns_interface_name "boulder" "eth0"

	    local container
	    container=dnsmasq
	    local dockerfile
	    IFS= read -r -d '' dockerfile <<EOF || :
FROM alpine:latest
RUN apk update && apk --no-cache add dnsmasq && rm -rf /var/cache/apk/*
EOF
	    local eargs
	    eargs=
	    earg --restart=unless-stopped
	    earg --net=host
	    earg --cap-add=NET_ADMIN
	    earg -v /run/systemd/resolve:/run/systemd/resolve

	    earg -v /dev/log:/dev/log
	    earg --log-driver=syslog
	    earg --log-opt syslog-facility=local1
	    earg --log-opt tag="${container}"

	    local docker_run_eargs
	    docker_run_eargs="${eargs}"

	    eargs=
	    earg -k
	    earg --no-resolv --resolv-file=/run/systemd/resolve/resolv.conf
	    earg  --localise-queries
	    earg --dhcp-range="${dev_vz_network_prefix}.100,${dev_vz_network_prefix}.199"
	    earg --dhcp-host="test-br,${dev_vz_network_prefix}.100"

	    eargs="${eargs}${extra_dnsmasq_eargs}"

	    start_docker_container "${container}" "${dockerfile}" \
		"${docker_run_eargs}" "dnsmasq ${eargs}"

	    write_file "/etc/resolv.conf" "nameserver 127.0.0.1${NL}"
	fi
    fi
}

setup_development_dpodctl() {
    local net_name="development"

    local dir="/opt/dpodctl"
    ensure_dir /opt/dpodctl

    local projects_root="/vol/projects"

    local i ip4_last_byte=10
    for i in transdock; do
	ensure_dir "$dir/$i"
	local ipv4="$dev_docker_network_prefix.$ip4_last_byte"
	: $((ip4_last_byte+=1))
	case $i in
	transdock )
	    add_dns_record_a media.mir2.org "${ipv4}"
	    add_dns_record_a test.media.mir2.org "${ipv4}"
	    write_file "$dir/$i/config.dpod" "\
IncludeBuild $projects_root/$i/config.dpod
DnsAlias media.mir2.org
DnsAlias test.media.mir2.org
HostEnv ACMELOOP_HOST 'media.mir2.org test.media.mir2.org'
HostEnv ACMELOOP_CA http://boulder:4000/directory
HostEnv ACMELOOP_CONTACT mailto:igor@mir2.org

HostEnv TLS_HOSTS 'media.mir2.org test.media.mir2.org'
HostEnv ACME_CA http://boulder:4000/directory
HostEnv ACME_CONTACT mailto:igor@mir2.org
BindAddress none
Network $net_name
NetworkIPv4 $ipv4
"
	    ;;
	esac
    done
}

show_usage=""
NAME=""
remote=""

while getopts :hn:r:u: opt; do
    case "$opt" in
	h ) show_usage=1 ;;
	n )
	    NAME="$OPTARG"
	    is_valid_host_name "$NAME" || \
		usage_err "The value of -n argument '$NAME' is not a known host name."
	    ;;
	r )
	    remote="$OPTARG"
	    is_valid_host_name "$remote" || \
		usage_err "The value of -r argument '$remote' is not a known host name."
	    ;;
	* ) getopts_err "$opt" "${OPTARG-}";;
    esac
done

#[[ $# -eq $(($OPTIND - 1)) ]] || usage_err "Unexpected extra arguments: $@"
let OPTIND==1+$# || usage_err "Unexpected extra arguments: $@"

[[ -z "$remote" || -z "$NAME" ]] || usage_err "Only one of -n, -r can be given"

if [[ -n "$show_usage" ]]; then
    echo "Usage: $0 [OPTION]..."
    echo "Customize installation for the given computer."
    echo
    echo "  -h  show this help and exit"
    echo "  -n name  assume the given name as the hostname rather than use /etc/hostname."
    echo "           The valid values are (${valid_host_names[*]})."
    echo "  -r name  execute setup on the remote machine name using ssh to copy the setup files."
    echo
    exit
fi

if [[ $remote ]]; then
    NAME=$remote
elif [[ -z "$NAME" ]]; then
    read_tliset_name
    NAME="$R"
fi

get_host_options

if [[ -n "$remote" ]]; then
    cmd=(run_remotely)
    if [[ ${machine_host} ]]; then
	cmd+=(-m "${machine_host}")
    fi
    if [[ ${ssh_login_user} ]]; then
	cmd+=(-u "${ssh_login_user}")
    fi
    "${cmd[@]}" -- "$remote" -n "$remote"
fi

if [[ "$(id -u)" -ne 0 ]]; then
    exec sudo "$0" "$@"
fi

determine_os

if let kind_fedora; then
    fedora_release="$(rpm -E %fedora)"
fi

setup_tliset

if ! under_qubes; then
    setup_packages
fi

start_generator_write

setup_kernel_parameters
setup_network
setup_services
setup_files
setup_accounts

finish_generator_write

# Run services after the docker is configured
setup_docker_services

log "Done."
