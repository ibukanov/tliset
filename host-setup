#!/bin/bash

source "$(dirname "$0")/lib.bash"

valid_host_names=(dserver miranda ultrabook untrusted hippyru thip r2)

is_valid_host_name() {
    local name="$1" i
    for i in "${valid_host_names[@]}"; do
	if [[ "$i" == "$name" ]]; then
	    return 0
	fi
    done
    return 1;
}

fixup_transgui() {
    local path=/usr/share/applications/transgui.desktop
    local line='MimeType=application/x-bittorrent;x-scheme-handler/magnet;'
    if ! grep -q "^$line\$" "$path" ; then
	log "fixing $path"
	local data="$(cat "$path" | grep -v '^MimeType=')"
	local tmp="$(mktemp "$path.XXXXXXXXXX")"
	tmp_files+=($tmp)
	printf '%s\n%s\n' "$data" "$line" > "$tmp"
	chmod 644 "$tmp"
	mv "$tmp" "$path"
    fi
}

setup_fedora_packages() {
    log "Checking packages"
    inc_log_level

    if let with_common_fedora_packages; then
	local rpmfusion_kinds=(
	    free
	    nonfree
	)
	local i rpmfusion_repos=()
	for i in "${rpmfusion_kinds[@]}"; do
	    rpmfusion_repos+=("rpmfusion-$i-release")
	done

	if ! rpm -q --quiet "${rpmfusion_repos[@]}" ; then
	    log "Installing rpmfusion"
	    local urls=()
	    for i in "${rpmfusion_kinds[@]}"; do
		urls+=("http://download1.rpmfusion.org/$i/fedora/rpmfusion-$i-release-$fedora_release.noarch.rpm")
	    done
	    dnf install -y --nogpgcheck "${urls[@]}" || true
	fi
    fi
    local list=()
    if let with_common_fedora_packages; then
	list+=(
	    tmux lxterminal
	    git fuse-sshfs lsyncd
	    quilt mercurial subversion
	    livecd-tools
	    autoconf automake gcc-c++ kernel-devel
	    emacs
	    tigervnc
	    strace

	    # filesystems
	    udftools inotify-tools fdupes fslint

	    # Archives
	    unrar libunrar

	    # encryption and backup
	    apg duplicity perl-Digest-Bcrypt python-gdata

	    # Recovery tools
	    ddrescue foremost scalpel testdisk

	    # Graphs
	    graphviz graphviz-doc

	    # PDF tools
	    pdfmerge poppler-utils

	    # Media
	    kdenlive
	    ffmpeg
	    vlc gimp inkscape gthumb
	    scribus
	    evince evince-djvu pdf2djvu
	    linux-libertine-biolinum-fonts linux-libertine-fonts
	    gstreamer1-libav
	    gstreamer1-plugins-bad-free
	    gstreamer1-plugins-bad-free-extras
	    gstreamer1-plugins-bad-freeworld
	    gstreamer1-plugins-good-extras
	    gstreamer1-plugins-ugly

	    # Languages
	    hunspell-ru hunspell-nb
	)

	if [[ -z "$virt" ]]; then
	    list+=(
		# hardware management
		rfkill lm_sensors
	    )

	    
	    list+=(
		# Assume this is only necessary on real hardware
		gnome-tweak-tool
		gnome-terminal-nautilus
		gnome-shell-extension-alternate-tab
	    )
	fi
    fi

    let with_latex && list+=(texlive)
    let with_transgui && list+=(transgui)

    if [[ -n "$virt" ]]; then
	list+=(gcc kernel-devel)
    fi

    case "$NAME" in
	dserver | miranda )
	    list+=(
		virt-manager
		virt-viewer
	    )
	    if [[ -z "$virt" ]]; then
		list+=(
		    libvirt-daemon-config-network
		    libvirt-daemon-kvm
		    qemu-kvm
		)
	    fi
	    ;;
    esac

    if [[ "$NAME" == miranda ]]; then
	list+=(tinyproxy firefox)
    fi

    for i in "${list[@]}"; do
	rpm -q --quiet "$i" || echo "Missed: $i"
    done

    if ! rpm -q --quiet "${list[@]}" ; then
	log "Installing missing packages"
	dnf install -y "${list[@]}"
    fi

    local remove_list=()

    if let with_transgui; then
	remove_list+=(transmission-gtk transmission-remote-gtk)
    fi
    if let with_networkd && let kind_fedora; then
	remove_list+=(network-manager-applet)
    fi
    if let ${#remove_list[@]}; then
	local status=0
	rpm -q --quiet "${remove_list[@]}" || status=$?
	if let "status < ${#remove_list[@]}"; then
	    cmd_log dnf remove -y "${remove_list[@]}"
	fi
	fixup_transgui
    fi

    printf 'new-session\n' | write_file /etc/tmux.conf

    dec_log_level
}

setup_fstab() {
    log "Checking fstab"
    local fstab ids edits id disk
    inc_log_level
    if [[ "$NAME" == dserver ]]; then
	log "Checking /etc/fstab"
	fstab="$(cat /etc/fstab)"
	# Replace lables/uids with real devices in fstab for security
	# as an untrusted VM will access the whole disk.
	ids=($(egrep -o '^UUID=[A-Fa-f0-9-]+' <<< "$fstab" | cut -d= -f2 || true))
	if [[ ${#ids[@]} -ge 1 ]]; then
	    log "replacing UUID with devices for security with untrusted VM"
	    edits=()
	    for id in "${ids[@]}"; do
		[[ -b "/dev/disk/by-uuid/$id" ]] || err "failed to locate disk for uuid=$id"
		disk="/dev/$(basename "$(readlink "/dev/disk/by-uuid/$id")")"
		[[ -b "$disk" && ! -L "$disk" ]] || \
		    err "/dev/disk/by-uuid/$id does not point to real device file"
		edits+=(-e "s|^UUID=$id|$disk|")
	    done
	    fstab="$(sed "${edits[@]}" <<< "$fstab")"
	fi

	fstab="$(sed '/^#custom-start#/,/^#custom-end#/d' <<< "$fstab")"
	fstab+='
#custom-start#
/dev/sda1 /area/backup ext4 noatime,discard
/dev/sda2 /area/kino ext4 noauto,noatime,discard
#custom-end#'

	write_file /etc/fstab "$fstab"
	if let file_update; then
	    log "/etc/fstab was updated"
	fi
	mkdir -p /area/backup
	mkdir -p /area/kino
    fi

    if [[ -n "$downloads_user" ]]; then
	local dirname=downloads
	local dir="/$dirname"
	local unitname="$dirname"
	if [[ ! -d "$dir" ]]; then
	    # TODO find out why systemd does not create the dir
	    # automatically.
	    log "creating $dir"
	    mkdir -m 0755 "$dir"
	fi
	if [[ -n "$virt" ]] ; then
	    p_file "\$1/$unitname.mount" "\
[Mount]
Where=$dir
Type=vboxsf
What=Downloads
Options=uid=$downloads_user,gid=$downloads_user,nosuid,nodev
"
	    p_file "\$1/$unitname.automount" "\
[Automount]
Where=$dir
"
            multi_user_wants+=("$unitname.automount")
	fi
    fi
    dec_log_level
}

setup_grub() {
    local key custom_grub_defaults edits grub_defaults_text grub_config
    local -A config
    log "Checking grub"

    local net_kernel_options=""
    if [[ -n "$virt" ]] && let kind_fedora; then
	# Disable predictable interface names under VM as they
	# complicates autoconfig.
	net_kernel_options=" net.ifnames=0"
    fi

    config=(
	[GRUB_DEFAULT]=saved
	[GRUB_TIMEOUT]=1
	[GRUB_CMDLINE_LINUX]="rhgb quiet LANG=en_US.UTF-8$net_kernel_options"
    )

    if [[ "$NAME" == dserver ]]; then
	# Avoid UUID for VM security
	config+=(
	    [GRUB_DISABLE_LINUX_UUID]=true
	)
    fi

    custom_grub_defaults=""
    for key in "${!config[@]}"; do
	custom_grub_defaults+="$(printf '\n%s=%q' "$key" "${config[$key]}")"
    done

    # Ensure stable order
    custom_grub_defaults="$(sort <<< "$custom_grub_defaults")"

    # delete all lines matching config keys and then append the proper values
    edits=()
    for key in "${!config[@]}"; do
	edits+=(-e "/^$key/d")
    done

    grub_defaults_text="$(sed "${edits[@]}" /etc/default/grub)$custom_grub_defaults"

    grub_config=/boot/grub2/grub.cfg
    [[ -f "$grub_config" ]] || grub_config=/boot/efi/EFI/fedora/grub.cfg
    [[ -f "$grub_config" ]] || err "Failed to locate grub.cfg"

    write_file /etc/default/grub "$grub_defaults_text"
    if let file_update; then
	log "updating $grub_config"
	grub2-mkconfig -o "$grub_config"
    fi
}

setup_network() {
    local -A hosts
    log "Checking network"
    inc_log_level

    hosts=(
#	[kino]=$ip_kino
    )

    if [[ ${#hosts[@]} -ne 0 ]]; then
	local hosts_text="" key edits
	for key in "${!hosts[@]}"; do
	    hosts_text+="$(printf '\n%s %s' "${hosts[$key]}" "$key")"
	done

	# Ensure stable order
	hosts_text="$(sort <<< "$hosts_text")"

	# delete all lines matching config keys and then append the proper values
	edits=()
	for key in "${!hosts[@]}"; do
	    edits+=(-e "/^[0-9.]\\+\\s\\+$key\$/d")
	done

	hosts_text="$(sed "${edits[@]}" /etc/hosts)$hosts_text"

	write_file /etc/hosts "$hosts_text"
    fi

    print_network
    if let with_dyndns; then
	print_dyndns
    fi
    if false && [[ "$NAME" == dserver ]]; then
	print_dserver_dnsmasq
    fi

    case "$NAME" in
	miranda ) install_miranda_network ;;
    esac

    if let with_resolved; then
	if [[ ! -L /etc/resolv.conf || \
		    "$(readlink /etc/resolv.conf)" != /run/systemd/resolve/resolv.conf ]]; then
	    cmd_log ln -s -f /run/systemd/resolve/resolv.conf /etc/resolv.conf
	fi

	# Switch system resolver to use systemd-resolved.
	if grep -q '^hosts:.*\<dns\>' /etc/nsswitch.conf; then
	    sed -i -e 's/^\(hosts:.*\)\<dns\>/\1resolve/' /etc/nsswitch.conf
	fi
    fi

    if let with_transmission_redirect; then
	setup_transmission_redirect
    fi

    dec_log_level
}

# Escape argument using single quotas
escape_for_shell() {
    local replacement="'\\''"
    printf %s "'${1//\'/$replacement}'"
}

start_generator_write() {
    multi_user_wants=()
    sockets_wants=()
    gen_body=""
}

print_wants_list() {
    local target="$1"
    shift
    let $# || return 0
    pl ''
    pl 'mkdir -p "$1/'"$target.d"'"'
    local i wants_body="[Unit]$NL"
    for i in "$@"; do
	wants_body+="Wants=$i$NL"
    done
    p_file '"$1/'"$target"'.d/tliset.conf"' "$wants_body"

}

finish_generator_write() {
    [[ -n "$gen_body" ]] || let "${#multi_user_wants[@]} + ${#socket_wants[@]}" || return

    print_wants_list multi-user.target "${multi_user_wants[@]:+${multi_user_wants[@]}}"
    print_wants_list sockets.target "${socket_wants[@]:+${socket_wants[@]}}"

    local prefix=''
    prefix+=$'#!/bin/sh\n'
    if true; then
	prefix+='
if [[ -z "${TLISET_HAS_LOG-}" ]]; then
    export TLISET_HAS_LOG=1
    exec "$0" "$@" > /run/tliset.log 2>&1
fi
date '+%Y-%m-%d_%H:%M:%S'
set -x
'
    fi
    prefix+=$'set -u\n'
    prefix+=$'mkdir -p /run/tliset\n'

    write_file -m 755 /etc/systemd/system-generators/tliset "$prefix$gen_body"
    if let file_update; then
	cmd_log systemctl daemon-reload
    fi
}

pl() {
    gen_body+="$1$NL"
}

# The first argument is path already properly quoted to read as single
# word in a shell. The second argument is text that should be written
# into the file at that path. Option -x indicattes that file must be
# executable.
p_file() {
    local -i executable=0
    if [[ "$1" == "-x" ]]; then
	shift
	executable=1
    fi
    local path="$1"
    local body="$2"
    pl "> $path printf %s $(escape_for_shell "$body")"
    if let executable; then
	pl "chmod 755 $path"
    fi
}

p_mask_service() {
    pl "ln -s /dev/null \"\$1/$1\""
}

print_network() {
    if let with_networkd && let kind_fedora; then
	multi_user_wants+=(systemd-networkd.service)
	pl ''
	pl 'mkdir -p "$1/sockets.target.d"'
	p_file '"$1/sockets.target.d/tliset.conf"' "\
[Unit]
Wants=systemd-networkd.socket
"
	# Mask all NetworkManager-related services
	p_mask_service NetworkManager.service
	p_mask_service NetworkManager-dispatcher.service
	p_mask_service NetworkManager-wait-online.service
	p_mask_service firewalld.service
	p_mask_service dbus-org.fedoraproject.FirewallD1.service

	# Make sure that system-supplied dnsmasq is masked
	p_mask_service dnsmasq.service
    fi
    if let with_resolved && let kind_fedora; then
	multi_user_wants+=(systemd-resolved.service)
    fi

    if let with_networkd; then
	pl ''
	pl 'net_dir="$1/../network"'
	pl 'mkdir -p "$net_dir"'
	pl 'chcon -t etc_t "$net_dir"'

	case "$NAME" in
	    dserver ) print_dserver_network_files ;;
	    * )
		if let kind_fedora; then
		    print_fedora_networkd_files
		fi
		;;
	esac
	print_virtualbox_network
    fi
}

print_dserver_network_files() {
    pl ''

    # Generate setup to allow for VMs that are accessible from the
    # lan. Use macvlan, not bridge, for beter efficiency.
    p_file '"$net_dir/80-macvlan.netdev"' "\
[NetDev]
Name=$dserver_bridge
Kind=macvlan
[MACVLAN]
Mode=bridge
"

    p_file '"$net_dir/80-lan.network"' "\
[Match]
MACAddress=80:ee:73:76:8f:4c
[Network]
MACVLAN=$dserver_bridge
"

    p_file '"$net_dir/80-macvlan.network"' "\
[Match]
Name=$dserver_bridge
[Network]
DHCP=ipv4
"

    # Print port forwarding initialization service and its scripts
    if false; then
	pl ''
	p_file '"$1/tliset-forward-ports.service"' "\
[Unit]
After=network-online.target

[Service]
Type=oneshot
RemainAfterExit=true
ExecStart=/run/tliset/open-ports
ExecStop=/bin/sh /run/tliset/close-ports
"

	pl 'mkdir -p "$1/network-online.target.wants"'
	pl 'ln -s "$1/tliset-forward-ports.service" "$1/network-online.target.wants"'
	p_file -x '/run/tliset/open-ports' "$(print_dserver_port_forwards)"
    fi
}

# Output string for a script that runs iptables to setup port
# forwarding and generate another script to close those. This 2-stage
# generation allows to close ports using the old definition after the
# open part is changed with new defines.
print_dserver_port_forwards() {
    local open_text="#!/bin/sh$NL"
    local close_text="#!/bin/sh$NL"
    local i
    for i in "${dserver_port_forwards[@]}"; do
	if [[ "$i" =~ ^(tcp|udp):([0-9]+):([0-9.]+)(:([0-9]+))?$ ]]; then
	    local protocol="${BASH_REMATCH[1]}"
	    local wan_port="${BASH_REMATCH[2]}"
	    local lan_ip="${BASH_REMATCH[3]}"
	    local lan_port="${BASH_REMATCH[5]}"
	    if [[ -z "$lan_port" ]]; then
		lan_port="$wan_port"
	    fi
	    local s="PREROUTING -t nat -i $dserver_eth_wan -p $protocol --dport $wan_port -j DNAT --to $lan_ip:$lan_port"
	    open_text+="iptables -A $s$NL"
	    close_text+="iptables -D $s$NL"
	else
	    err "Bad port forwarding spec: $i"
	fi
    done

    open_text+="> /run/tliset/close-ports printf %s $(escape_for_shell "$close_text")$NL"
    open_text+="chmod 755 /run/tliset/close-ports$NL"
    printf %s "$open_text"
}

print_dyndns() {
    if [[ ! -s /etc/duckdns.key ]]; then
	[[ -t 1 ]] || err "cannot ask for /etc/duckdns.key value as input is not tty"
	local api_key
	IFS='' read -p 'Enter API key for www.duckdns.org: ' api_key
	write_file -m 640 -o root:nobody /etc/duckdns.key "$api_key"
    fi
    local key="$(< /etc/duckdns.key)"
    local url="https://www.duckdns.org/update?domains=dsrv&token=$key&ip="

    multi_user_wants+=(tliset-dyndns.timer)
    pl ''
    p_file '"$1/tliset-dyndns.timer"' "\
[Unit]
After=network-online.target
Wants=network-online.target

[Timer]
Persistent=true
# Each 10 minutes
OnCalendar=*:0/10
"
    p_file '"$1/tliset-dyndns.service"' "\
[Unit]
After=network-online.target
Wants=network-online.target

[Service]
User=nobody
Type=oneshot
ExecStart=/run/tliset/dyndns-update
"
    p_file -x '/run/tliset/dyndns-update' '#!/bin/sh
s="$(/usr/bin/curl -s '"$(escape_for_shell "$url")"')"
printf "curl output: %s\n" "$s" 1>&2
test OK = "$s"
'
}

print_dserver_dnsmasq() {

    local -a dnsmasq_config
    mapfile -t dnsmasq_config <<EOF

interface=$dserver_bridge
#interface=br0
domain-needed
bogus-priv

# for now use Google's services
no-resolv
server=8.8.8.8
server=8.8.4.4

no-hosts
dhcp-range=192.168.2.50,192.168.2.150,6h

address=/dserver/192.168.2.10
address=/dserver.mir2.org/192.168.2.10

dhcp-host=08:60:6E:CD:96:68,192.168.2.2
address=/wifi/192.168.2.2

# Virtual machine needs a stable ip to use with iptables rules
dhcp-host=$mac_kino,$ip_kino
address=/kino/$ip_kino
address=/extra.mir2.org/$ip_kino

dhcp-host=$mac_macbook_air,$ip_macbook_air

# Terentiy's tablet
dhcp-host=$mac_tablet,$ip_tablet

#dhcp-option=option:router,192.168.2.1
EOF

    # For simpler setup convert config into a list of options while
    # stripping spaces, comments and blunk lines and embedd it
    # directly into the unit file.
    local i s=''
    for i in "${dnsmasq_config[@]}"; do
	i="${i## }"
	i="${i%% }"
	i="${i%%#*}"
	if [[ -n "$i" ]]; then
	    s+=" \\$NL    --$i"
	fi
    done

    multi_user_wants+=(tliset-dnsmasq.service)

    pl ''
    p_file '"$1/tliset-dnsmasq.service"' "\
[Unit]
After=network.target

[Service]
ExecStart=/usr/sbin/dnsmasq -k --conf-file=/dev/null$s
"
}

print_fedora_networkd_files() {
    p_file '"$net_dir/zz-default.network"' "\
[Network]
DHCP=v4

[DHCP]
UseMTU=true
UseDomains=true
"
}

print_virtualbox_network() {
    let with_virtualbox_net || return 0

    p_file '"$net_dir/99-virt-eth1.network"' "\
[Match]
Name=eth1
Virtualization=vm

[Network]
LinkLocalAddressing=yes
LLMNR=yes
"
}

install_miranda_network() {

    if [[ -z "$virt" ]]; then
	# TODO use dnsmasq to integrate with VM names
	write_file /etc/NetworkManager/conf.d/99-local.conf <<EOF
[main]
#dns=dnsmasq
EOF
	if let file_update; then
	    cmd_log systemctl restart NetworkManager
	fi
    fi
}

setup_transmission_redirect() {
    local ports=($kino_transmission_port) port
    if [[ "$NAME" == untrusted ]]; then
	ports+=(9090)
    fi
    for port in "${ports[@]}"; do
	pl ''
	p_file "\"\$1/tliset-transmission-$port.socket\"" "\
[Socket]
Accept=true
ListenStream=127.0.0.1:$port
"
	pl ''
	p_file "\"\$1/tliset-transmission-$port@.service\"" "\
[Unit]
Requires=tliset-transmission-$port.socket

[Service]
StandardInput=socket
ExecStart=/usr/bin/ssh -W127.0.0.1:$port \\
  -o StrictHostKeyChecking=no -o UserKnownHostsFile=$autofs_ssh_known_hosts kino
"
    done
    if let with_networkd; then
	for port in "${ports[@]}"; do
	    multi_user_wants+=("tliset-transmission-$port.socket")
	done
    else
	multi_user_wants+=(NetworkManager-dispatcher)
	pl ''
	p_file -x "/run/tliset/is-online" "$(cat <<'EOF'
#!/bin/sh
case "$(nmcli -f STATE -t g)" in
    connected | "connected (site only)" ) exit 0 ;;
esac
exit 1
EOF
)"
	pl ''
	p_file -x "/run/tliset/is-outside-home-net" "$(cat <<'EOF'
#!/bin/sh
! grep -q '^nameserver[[:space:]]\+192\.168\.2\.[0-9]\+$' /etc/resolv.conf
EOF
)"

	socket_units=""
	for port in "${ports[@]}"; do
	    socket_units+=" tliset-transmission-$port.socket"
	done
	write_file -m 755 /etc/NetworkManager/dispatcher.d/90-online-monitor <<EOF
#!/bin/bash
if /run/tliset/is-online; then
    systemctl start$socket_units
else
    systemctl stop$socket_units
fi
EOF
    fi
}

setup_ssh_config() {
    local config_path=/run/tliset/ssh_config
    local bind_path=/etc/ssh/ssh_config
    local extra=''
    if [[ "$NAME" == miranda || "$NAME" == untrusted ]]; then
	extra+="
Host thip
  HostKeyAlias thip
  CheckHostIP no
  User core

Host t-transdock
  HostKeyAlias t-transdock
  HostName thip
  User user
  Port $transdock_ssh_port
  Ciphers aes128-gcm@openssh.com
"
    fi

    p_file "$config_path" "\
Host kino
  HostKeyAlias kino
  AddressFamily inet
  CheckHostIP no
  Port 9092
  HostName media.mir2.org
  User user
  Ciphers aes128-gcm@openssh.com
  MACs umac-128@openssh.com

Host dserver
  HostKeyAlias dserver
  HostName dserver.mir2.org
  AddressFamily inet
  CheckHostIP no
  Port 18022
  Ciphers aes128-gcm@openssh.com
  MACs umac-128@openssh.com

Host hippyru-www
  HostKeyAlias hippyru-www
  HostName www.hippyru.net
  AddressFamily inet
  CheckHostIP no
  Port 2022
  Ciphers aes128-gcm@openssh.com
$extra
Host *
  GSSAPIAuthentication no
  SendEnv LANG
"

    local unitname="$(systemd-escape -p "$bind_path")"
    p_file "\$1/$(printf %q "$unitname.mount")" "\
[Mount]
Where=$bind_path
Type=none
Options=bind
What=$config_path
"
    multi_user_wants+=("$unitname.mount")
}

setup_net_mounts() {

    local autofs_dirs=(kino)
    if [[ "$NAME" == miranda || "$NAME" == ultrabook ]]; then
	autofs_dirs+=(bergenrabbit dserver-lubava hippy.ru lubava.info)
    fi

    local mount_root=/run/tliset/set
    pl "mkdir -p ${autofs_dirs[*]/#/$mount_root/}"
    multi_user_wants+=(autofs.service)

    local s="" dir host remote_user remote_dir
    for dir in "${autofs_dirs[@]}"; do
	local extra_opt=""
	case "$dir" in
	    bergenrabbit )
		host=hippyru-www
		remote_user=bergenrabbit.net
		remote_dir=/www/site/bergenrabbit.net
		;;
	    hippy.ru )
		host=hippyru-www
		remote_user=hippy.ru
		remote_dir=/www/site/hippy.ru
		;;
	    lubava.info )
		host=hippyru-www
		remote_user=lubava.info
		remote_dir=/www/site/lubava.info
		;;
	    kino )
		host=kino
		remote_user=user
		remote_dir=/files
		extra_opt="max_readahead=1048576"
		#extra_opt="max_readahead=4194304"
		;;
	    dserver-lubava )
		host=dserver
		remote_user=lubava
		remote_dir=/home/lubava
		;;
	esac

	local local_user
	case "$NAME" in
	    dserver ) local_user=kino ;;
	    miranda ) local_user=igor ;;
	    ultrabook ) local_user=lubava ;;
	    untrusted ) local_user=user ;;
	esac

	local opt=""
	opt+="rw,nodev,nosuid,noatime,allow_other,nonempty"
	opt+=",max_read=65536,reconnect,intr"
	opt+=",workaround=all,transform_symlinks,follow_symlinks"
	opt+=",ServerAliveInterval=5,ServerAliveCountMax=2"
	opt+=",StrictHostKeyChecking=no"
	opt+=",UserKnownHostsFile=$autofs_ssh_known_hosts"
	opt+=",ControlPath=none"
	opt+=",uid=$(id -u "$local_user"),gid=$(id -g "$local_user")"
	opt+="${extra_opt:+,}$extra_opt"
	
	local mount_dir="$mount_root/$dir"
	local unitname="$(systemd-escape -p "$mount_dir")"
	p_file "\$1/$(printf %q "$unitname.mount")" "\
[Mount]
Where=$mount_dir
Type=fuse.sshfs
What=$remote_user@$host:$remote_dir
Options=$opt
"
	# Using TimeoutIdleSec leads to a hung after network is
	# recovered after first successful mount.
	p_file "\$1/$(printf %q "$unitname.automount")" "\
[Automount]
Where=$mount_dir
#TimeoutIdleSec=30
"
        multi_user_wants+=("$unitname.automount")
    done
    write_file "$autofs_ssh_known_hosts" ""

    if [[ ! -L /set || "$(readlink /set)" != "$mount_root" ]]; then
	cmd_log rm -f /set
	cmd_log ln -s "$mount_root" /set
    fi
}

setup_sshd() {
    log "Checking sshd"
    inc_log_level
    mkdir -p -m 0700 /root/.ssh
    if [[ ! -f /root/.ssh/id_ed25519 ]]; then
	log "Generating ssh key for the root user"
	ssh-keygen -t ed25519 -N '' -f /root/.ssh/id_ed25519
    fi

    # Based on https://stribika.github.io/2015/01/04/secure-secure-shell.htlm
    local sshd_config="\
UsePrivilegeSeparation sandbox

KexAlgorithms curve25519-sha256@libssh.org,diffie-hellman-group-exchange-sha256
HostKey /etc/ssh/ssh_host_ed25519_key
Ciphers chacha20-poly1305@openssh.com,aes256-gcm@openssh.com,aes128-gcm@openssh.com
MACs hmac-sha2-512-etm@openssh.com,hmac-sha2-256-etm@openssh.com,hmac-ripemd160-etm@openssh.com,umac-128-etm@openssh.com,hmac-sha2-512,hmac-sha2-256,hmac-ripemd160,umac-128@openssh.com

UseDNS no
ClientAliveInterval 180

AuthorizedKeysFile /etc/ssh/authorized_keys/%u
Subsystem sftp /usr/libexec/openssh/sftp-server

PasswordAuthentication no
ChallengeResponseAuthentication no
"
    if let kind_fedora; then
	sshd_config+="\
GSSAPIAuthentication no
UsePAM yes
"
    fi

    write_file /etc/ssh/sshd_config "$sshd_config"

    local root_authorized_keys="$ssh_pubkey_igor"

    if [[ "$NAME" == dserver ]]; then
	# Allow root to ssh to self for debugging
	root_authorized_keys+="$(< /root/.ssh/id_ed25519.pub)$NL"
    fi

    if let sshd_extra_listen_port && let kind_fedora; then
	local re='^ssh_port_t\s\+tcp\s\+%s$'
	if ! semanage port -l -C | grep -q "$(printf "$re" "$sshd_extra_listen_port")"; then
	    cmd_log semanage port -a -t ssh_port_t -p tcp "$sshd_extra_listen_port"
	fi
    fi

    file_update_count=0
    if let kind_fedora; then
	ports=" -o Port=22"
	if let sshd_extra_listen_port; then
	    ports+=" -o Port=$sshd_extra_listen_port"
	fi

	pl 'mkdir -p "$1/sshd.service.d/"'
	p_file '"$1/sshd.service.d/tliset.conf"' "\
[Service]
Environment=\"OPTIONS=-e$ports\"
"
    elif let kind_coreos; then
	if let sshd_extra_listen_port; then
	    pl 'mkdir -p "$1/sshd.socket.d/"'
	    p_file '"$1/sshd.socket.d/tliset.conf"' "\
[Socket]
ListenStream=$sshd_extra_listen_port
"
	fi
    fi

    if let with_enabled_sshd; then
	# On coreos this is enabled by default
	if let kind_fedora; then
	    multi_user_wants+=(sshd.service)
	fi
    else
	if systemctl -q is-enabled sshd; then
	    log "disabling sshd"
	    systemctl disable sshd
	fi
    fi

    if let file_update_count && systemctl -q is-active sshd; then
	log "restarting sshd"
	systemctl restart sshd
    fi

    write_file -m 640 /etc/ssh/authorized_keys/root "$root_authorized_keys"
    if let kind_coreos; then
	write_file -m 640 -o root:core /etc/ssh/authorized_keys/core "$root_authorized_keys"
	remove_file /home/core/.ssh/authorized_keys.d/coreos-cloudinit
	remove_file /home/core/.ssh/authorized_keys
    fi
    if [[ "$NAME" == dserver ]]; then
	# Also allow the admin to login directly as user so sshfs from
	# the admin account to the user dir works.
	write_file -m 640 -o root:lubava /etc/ssh/authorized_keys/lubava \
		   "$root_authorized_keys$ssh_pubkey_lubava"
    fi
    dec_log_level
}

add_user() {
    local user="$1" id="$2"
    if ! id -u "$user" 2>/dev/null 1>&2; then
	log "creating user name=$user id=$id"
	groupadd -g "$id" "$user"
	useradd -g "$id" -u "$id" "$user"
	passwd -d "$user"
    fi
}

setup_users() {
    log "Checking users"
    inc_log_level
    if [[ "$NAME" == dserver || "$NAME" == ultrabook || "$NAME" == miranda ]]; then
	add_user lubava 1978
    fi
    if [[ "$NAME" == dserver ]]; then
	add_user kino 1001
    fi
    if [[ "$NAME" == miranda ]]; then
	add_user igor 1973
	if ! getent group vboxsf >/dev/null ; then
	    cmd_log usermod -a -G vboxsf igor
	fi
    fi
    dec_log_level
}

setup_services() {
    log "Checking services"
    inc_log_level

    let with_net_mounts && setup_net_mounts

    if let kind_fedora; then
	setup_ssh_config
    fi

    if let kind_fedora; then
	p_mask_service docker.service
    fi

    if let kind_coreos; then
	# Ignore system and user configs
	p_mask_service system-cloudinit@.servive
	p_mask_service user-cloudinit@.servive

	# On CoreOS docker is socket-activated by default which breaks
	# restarting containers on boot unless a docker client runs
	multi_user_wants+=(docker.service)
    fi

    if let with_vol_storage; then
	p_file -x '/run/tliset/mount-vol' "$(cat <<'EOF'
#!/bin/sh
set -e -u
mkdir -p /vol
root_mount="$(grep ' / ' /proc/mounts)"
root_device_prefix="${root_mount%%[0-9]*}"
case "$root_device_prefix" in
    /dev/sda ) device=/dev/sdb ;;
    /dev/vda ) device=/dev/vdb ;;
    * ) echo "Cannot deduce storage device, root_device_prefix='$root_device_prefix' root_mount='$root_mount'" 1>&2; exit 1 ;;
esac

test -b "$device" || { echo "No extra storage" 1>&2; exit 0; }
if ! grep -q "^$device\>" /proc/mounts && ! mount -t ext4 "$device" /vol 2>/dev/null; then
    set -x
    mkfs.ext4 "$device"
    mount -t ext4 "$device" /vol
    set +x
fi
if [[ ! -d /vol/src ]]; then
    set -x
    tmp="$(mktemp -d -p /vol)"
    chmod 755 "$tmp" && chown core:core "$tmp" && mv "$tmp" /vol/src || \
        { rmdir "$tmp"; exit 1; }
    set +x
fi
if [[ ! -d /vol/docker ]]; then
    mkdir -m 755 /vol/docker
fi
mount --bind /vol/docker /var/lib/docker
EOF
)"
	p_file -x '"$1/tliset-mount-vol.service"' "$(cat <<'EOF'
[Unit]
Before=docker.service
[Service]
Type=oneshot
ExecStart=/run/tliset/mount-vol
EOF
)"
	multi_user_wants+=(tliset-mount-vol.service)
    fi

    dec_log_level
}

. "$selfdir/zram-setup"

show_usage=""
NAME=""
remote=""

while getopts :hn:r: opt; do
    case "$opt" in
	h ) show_usage=1 ;;
	n )
	    NAME="$OPTARG"
	    is_valid_host_name "$NAME" || \
		usage_err "The value of -n argument '$NAME' is not a known host name."
	    ;;
	r )
	    remote="$OPTARG"
	    is_valid_host_name "$remote" || \
		usage_err "The value of -n argument '$remote' is not a known host name."
	    ;;
	\? ) usage_err "option -$OPTARG requires an argument" ;;
	* ) usage_err "unknown -$OPTARG option" ;;
    esac
done

#[[ $# -eq $(($OPTIND - 1)) ]] || usage_err "Unexpected extra arguments: $@"
let OPTIND==1+$# || usage_err "Unexpected extra arguments: $@"

[[ -z "$NAME" || -z "$remote" ]] || usage_err "Only one of -n, -r can be given"

if [[ -n "$show_usage" ]]; then
    echo "Usage: $0 [OPTION]..."
    echo "Customize installation for the given computer."
    echo
    echo "  -h  show this help and exit"
    echo "  -n name  assume the given name as the hostname rather than use /etc/hostname."
    echo "           The valid values are (${valid_host_names[*]})."
    echo "  -r name  execute setup on the remote machine name using ssh to copy the setup files."
    echo
    exit
fi

if [[ -n "$remote" ]]; then
    run_remotely "$remote" -n "$remote"
fi

if [[ "$(id -u)" -ne 0 ]]; then
    exec sudo "$0" "$@"
fi

if [[ -z "$NAME" ]]; then
    IFS='' read NAME < /etc/hostname
    if ! is_valid_host_name "$NAME"; then
	err "The content of /etc/hostname is '$NAME' is not a supported name." \
	    "Use -n option to set the hostname explicitly."
    fi
else
    if [[ -f /etc/hostname ]]; then
	IFS='' read current_hostname < /etc/hostname
	if is_valid_host_name "$current_hostname" && [ "$NAME" != "$current_hostname" ]; then
	    err "Already setup as $current_hostname. To force put localhost into /etc/hostname"
	fi
    fi
    echo "$NAME" > /etc/hostname
fi

declare -i kind_fedora=0
declare -i kind_coreos=0
declare -i with_vol_storage=0
declare -i with_zram=1
declare -i with_networkd=0
declare -i with_resolved=0
declare -i with_dyndns=0
declare -i with_transmission_redirect=0
declare -i with_latex=0
declare -i with_transgui=0
declare -i with_net_mounts=0
declare -i with_common_fedora_packages=0

declare -i with_enabled_sshd=1
declare -i sshd_extra_listen_port=0

declare -i with_virtualbox_net=0

downloads_user=""

virt="$(systemd-detect-virt -v || true)"
if [[ "$virt" == none ]]; then
    virt=""
fi

case "$NAME" in
    dserver )
	kind_fedora=1
	with_networkd=1
	with_resolved=1
	with_dyndns=1
	with_transmission_redirect=1
	sshd_extra_listen_port=18022
	with_net_mounts=1
	;;
    ultrabook )
	kind_fedora=1
	with_common_fedora_packages=1
	with_transgui=1
	with_transmission_redirect=1
	with_net_mounts=1
	with_enabled_sshd=0
	;;
    miranda )
	kind_fedora=1
	if [[ -n "$virt" ]]; then
	    with_networkd=1
	    with_resolved=1
	fi
	with_virtualbox_net=1
	with_common_fedora_packages=1
	with_latex=1
	with_enabled_sshd=0
	sshd_extra_listen_port=19022
	with_net_mounts=1
	downloads_user=igor
	;;
    untrusted )
	kind_fedora=1
	with_common_fedora_packages=1
	with_networkd=1
	with_resolved=1
	with_virtualbox_net=1
	with_net_mounts=1
	with_transmission_redirect=1
	with_transgui=1
	downloads_user=user
	;;
    thip )
	kind_coreos=1
	with_vol_storage=1
	with_zram=1
	with_virtualbox_net=1
	;;
    hippyru )
	kind_coreos=1
	with_zram=1
	;;
    rserv )
	kind_coreos=1
	with_zram=1
	;;
    r2 )
	kind_coreos=1
	with_zram=1
	;;
esac

if let kind_coreos && ! let with_enabled_sshd; then
    err "On CoreOS sshd must always be enabled"
fi

if let kind_coreos; then
    with_networkd=1
    with_resolved=1
fi

#if let kind_coreos; then
#    [[ ! -d /media/configdrive && ! -d /media/configvirtfs ]] || \
#	err "Cannot configure CoreOS that under cloudconfig control"
#fi

if [[ -z "$virt" ]] && let with_virtualbox_net; then
    with_virtualbox_net=0
fi

if let kind_fedora; then
    fedora_release=$(rpm -E %fedora)
fi

start_generator_write

if let kind_fedora; then
    setup_fstab
    setup_fedora_packages
    setup_grub
fi
if let with_zram; then
    setup_zram
fi
setup_sshd
setup_network
if let kind_fedora; then
    setup_users
fi
setup_services

finish_generator_write
log "Done."
