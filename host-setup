#!/bin/bash

source "$(dirname "$0")/lib.bash"

#set -x

valid_host_names=(bergenrabbit r2 rhea thip)

declare -i kind_coreos=0
declare -i kind_fedora=0
declare -i kind_ubuntu=0

declare zram_size=
declare -i with_zswap=0
declare -i with_latex=0
declare -i with_transgui=0
declare -i with_common_packages=0
declare -i with_include_rpmfusion=1

declare -i with_docker=0
declare -i with_sudoless_docker=0
declare -i with_docker_development_net=0
declare -i with_http_proxy=0

declare hippyru_backup_time=

declare ssh_login_user=

# These 2 are deduced automatically
declare primary_user=
declare primary_group=

declare extra_system_users=()

declare -a explicit_ipv6=()

# Replace lables/uids with real devices in fstab/grub for security
# when allowing untrusted VM to access the whole disk.
declare -i with_disabled_disk_uuid=0

readonly dev_docker_network_prefix="192.168.96"

declare extra_etc_hosts=

readonly gen_self_dir="/run/tliset"
readonly gen_scripts="$gen_self_dir"
readonly gen_config="$gen_self_dir"
readonly gen_mount="$gen_self_dir/set"



get_host_options() {
    case "$NAME" in
	bergenrabbit )
	    ssh_login_user=core
	    with_docker=1
	    zram_size=512M
	    ;;
 	r2 )
	    hippyru_backup_time=03:00:02
	    explicit_ipv6=(2001:41d0:e:696::1/64 2001:41d0:e:6ff:ff:ff:ff:ff)
	    ssh_login_user=core
	    with_docker=1
	    zram_size=512M
	    ;;
 	rhea )
	    with_common_packages=1
	    with_docker=1
	    zram_size=8G

	    # disable until user namespaces works
	    with_sudoless_docker=0
	    ;;
	thip )
	    ssh_login_user=core
	    with_docker=1
	    with_docker_development_net=1
	    ;;
	* )
	    err "unknown '$NAME'"
	    ;;
    esac
}

determine_os() {
    local os_kind=
    if [[ -f /etc/os-release ]]; then
        local line
        {
            while IFS='' read -r line; do
                if [[ $line =~ ^ID=(.*)$ ]]; then
                    os_kind="${BASH_REMATCH[1]}"
                    break;
                fi
            done
        } < /etc/os-release
    fi

    case "${os_kind,,}" in
	ubuntu ) kind_ubuntu=1 ;;
	fedora ) kind_fedora=1 ;;
	coreos | "") kind_coreos=1 ;;
	* ) err "Do not know how to determine OS, os_kind='$os_kind'" ;;
    esac
}

under_qubes() {
    if [[ ! -v under_qubes_flag ]]; then
	if [[ -d /etc/qubes ]]; then
	    declare -r -g under_qubes_flag=1
	else
	    declare -r -g under_qubes_flag=0
	fi
    fi
    let under_qubes_flag && return 0
    return 1
}

is_valid_host_name() {
    local name="$1" i
    for i in "${valid_host_names[@]}"; do
	if [[ "$i" == "$name" ]]; then
	    return 0
	fi
    done
    return 1;
}

read_tliset_name() {
    R=''
    local path=/etc/tliset.name name
    if under_qubes; then
	path="/usr/local$path"
    fi
    [[ -s "$path" ]] || \
	err "$path does not exist or empty. Initilize it with a valid name and try again."
    IFS='' read -r name < "$path"
    local name_pattern='^[a-z0-9]+$'
    [[ $name =~ $name_pattern ]] || \
	err "$path content does not match $name_pattern - '$name'"
    R="$name"
}

fixup_transgui() {
    local path=/usr/share/applications/transgui.desktop
    local line='MimeType=application/x-bittorrent;x-scheme-handler/magnet;'
    if ! grep -q "^$line\$" "$path" ; then
	log "fixing $path"
	local data="$(cat "$path" | grep -v '^MimeType=')"
	local tmp="$(mktemp "$path.XXXXXXXXXX")"
	tmp_files+=($tmp)
	printf '%s\n%s\n' "$data" "$line" > "$tmp"
	chmod 644 "$tmp"
	mv "$tmp" "$path"
    fi
}

setup_packages() {
    let kind_fedora || let kind_ubuntu || return 0

    log "Checking packages"
    inc_log_level
    let kind_fedora && setup_fedora_packages
    let kind_ubuntu && setup_ubuntu_packages
    dec_log_level
    return 0
}


setup_fedora_packages() {
    if let with_common_packages && let with_include_rpmfusion; then
	local rpmfusion_kinds=(
	    free
	    nonfree
	)
	local i rpmfusion_repos=()
	for i in "${rpmfusion_kinds[@]}"; do
	    rpmfusion_repos+=("rpmfusion-$i-release")
	done

	if ! rpm -q --quiet "${rpmfusion_repos[@]}" ; then
	    log "Installing rpmfusion"
	    local urls=()
	    for i in "${rpmfusion_kinds[@]}"; do
		urls+=("http://download1.rpmfusion.org/$i/fedora/rpmfusion-$i-release-$fedora_release.noarch.rpm")
	    done
	    dnf install -y --nogpgcheck "${urls[@]}" || true
	fi
    fi
    local list=()
    if let with_common_packages; then
	list+=(
	    tmux
	    git lsyncd
	    quilt mercurial subversion
	    livecd-tools
	    autoconf automake gcc-c++ kernel-devel
	    emacs
	    geany geany-plugins-spellcheck
	    tigervnc
	    dstat strace
	    xclip xorg-x11-apps
	    xpra
	    xorg-x11-server-Xephyr
	    openssh-askpass

	    # filesystems
	    udftools inotify-tools fdupes fslint

	    # encryption and backup
	    apg duplicity perl-Digest-Bcrypt python-gdata

	    # Recovery tools
	    ddrescue foremost scalpel testdisk

	    # Graphs
	    graphviz graphviz-doc

	    # PDF tools
	    pdfmerge poppler-utils

	    # Media
	    gimp inkscape gthumb
	    scribus
	    evince evince-djvu pdf2djvu
	    linux-libertine-biolinum-fonts linux-libertine-fonts
	    gstreamer1-plugins-good-extras

	    # Languages
	    hunspell-ru hunspell-nb
	)

	if let with_include_rpmfusion; then
	    list+=(
		# Archives
		unrar libunrar

		# Media
		vlc
		kdenlive
		ffmpeg
		gstreamer1-libav
		gstreamer1-plugins-bad-free
		gstreamer1-plugins-bad-free-extras
		gstreamer1-plugins-bad-freeworld
		gstreamer1-plugins-ugly
	    )
	fi

	list+=(
	    # hardware management
	    rfkill lm_sensors
	)


	list+=(
	    gnome-tweak-tool
	    gnome-terminal-nautilus
	    gnome-shell-extension-alternate-tab
	)
    fi

    let with_latex && list+=(
	    texlive
	    texlive-babel-norsk
	    texlive-babel-russian
	    texlive-collection-langcyrillic
	)
    let with_transgui && list+=(transgui openssl-devel)

    list+=(gcc kernel-devel)

    if let with_docker; then
	list+=(
	    docker
	)
    fi

    for i in "${list[@]}"; do
	rpm -q --quiet "$i" || echo "Missed: $i"
    done

    if ! rpm -q --quiet "${list[@]}" ; then
	log "Installing missing packages"
	dnf install -y "${list[@]}"
    fi

    local remove_list=()

    if let with_transgui; then
	remove_list+=(transmission-gtk transmission-remote-gtk)
    fi
    if let ${#remove_list[@]}; then
	local status=0
	rpm -q --quiet "${remove_list[@]}" || status=$?
	if let "status < ${#remove_list[@]}"; then
	    cmd_log dnf remove -y "${remove_list[@]}"
	fi
	fixup_transgui
    fi

    printf 'new-session\n' | write_file /etc/tmux.conf
}

setup_ubuntu_packages() {
    local -a install_list=() remove_list=()
    install_list+=(
	build-essential make-doc gcc g++ pkgconf
	git git-man liberror-perl
	emacs24 emacs24-el xterm xfonts-base
	xtightvncviewer xclip
	lsyncd apg apt-file libdigest-bcrypt-perl duplicity
    )

    if let with_common_packages; then
	install_list+=(
	    dstat
	    libreoffice
	    gvfs-bin
	    libglib2.0-dev
	    libgnome-keyring-dev
	    ffmpeg
	    firejail
	    xpra
	    xephyr
	)
    fi

    let with_transgui && install_list+=(transgui)
    remove_list+=(transmission-common)

    if let with_latex; then
	install_list+=(
	    texlive
	    texlive-lang-cyrillic
	    texlive-lang-european
	)
    fi

    remove_list+=(
	resolvconf
    )

    local -A package_status_map=()

    local -a apt_action_list=()
    fill_apt_action_list install "${install_list[@]:+${install_list[@]}}"
    if [[ ${#apt_action_list[@]} -ne 0 ]]; then
	log "Installing missing packages"
	DEBIAN_FRONTEND=noninteractive cmd_log apt-get install -y "${apt_action_list[@]}"
    fi

    local -a apt_action_list=()
    fill_apt_action_list uninstall "${remove_list[@]:+${remove_list[@]}}"
    if [[ ${#apt_action_list[@]} -ne 0 ]]; then
	log "Purging unnecessary packages ${remove_list[*]}"
	DEBIAN_FRONTEND=noninteractive apt-get purge -y "${apt_action_list[@]}"
    fi
}

fill_apt_action_list() {
    local action="$1"
    shift
    [[ $# -ne 0 ]] || return 0

    # Complication: for unknown packages dpkg-query reports an error,
    # so parse both stdout and stderr.
    local status_package_re='^#stdout ([^ ]+)  ([^ ]+)$'
    local unknown_package_message_re='^dpkg-query: no packages found matching ([^ ]+)$'
    local output
    output="$(dpkg-query -W --showformat '#stdout ${db:Status-Abbrev} ${Package}\n' "$@"  2>&1 || :)"
    if [[ $output ]]; then
	local -a lines
	mapfile -t lines <<< "$output"
	local line
	for line in "${lines[@]}"; do
	    if [[ $line =~ $unknown_package_message_re ]]; then
		local package="${BASH_REMATCH[1]}"
		local status="unknown"
	    elif [[ $line =~ $status_package_re ]]; then
		local status="${BASH_REMATCH[1]}"
		local package="${BASH_REMATCH[2]}"
		case $status in
		    ii ) status=installed ;;
		    un ) status=uninstalled ;;
		    * ) err "unexpected dpkg-query status '$status': $line" ;;
		esac
		package_status_map[$package]="$status"
	    else
		err "unexpected dpkg-query output: $line"
	    fi
	    if [[ $action == install ]]; then
		if [[ $status == installed ]]; then
		    continue
		fi
	    elif [[ $action == uninstall ]]; then
		# purge both installed packages and packages with config-files
		if [[ $status != installed && $status != config-files ]]; then
		    continue
		fi
	    else
		err "bad action: $action"
	    fi
	    apt_action_list+=("$package")
	done
    fi
}

# Escape argument using single quotas with with each single quote in
# arg replaced by '"'"'
escape_for_shell() {
    local arg="$1"
    if [[ $arg =~ ^[-_./a-zA-Z0-9]+$ ]]; then
	R="$arg"
    else
	local escaped=
	while : ; do
	    local before_quote="${arg%%\'*}"
	    [[ $arg != "$before_quote" ]] || break
	    escaped="$escaped$before_quote'\"'\"'"
	    arg="${arg#*\'}"
	done
	printf -v R %s "'$escaped$arg'"
    fi
}

start_generator_write() {
    multi_user_wants=()
    sockets_wants=()
    gen_body=()
    gen_mkdir_list=()
}

print_wants_list() {
    local target="$1"
    shift
    let $# || return 0
    p_nl
    p_dir "service:$target.d"
    local i wants_body="[Unit]$NL"
    for i in "$@"; do
	wants_body+="Wants=$i$NL"
    done
    p_file "service:$target.d/tliset.conf" "$wants_body"
}

finish_generator_write() {
    p_dir scripts:
    print_wants_list multi-user.target "${multi_user_wants[@]:+${multi_user_wants[@]}}"
    print_wants_list sockets.target "${socket_wants[@]:+${socket_wants[@]}}"

    local script="#!/bin/sh$NL"
    if true; then
		script+='
if [[ -z "${TLISET_HAS_LOG-}" ]]; then
    export TLISET_HAS_LOG=1
    mkdir -p /run/tliset
    exec "$0" "$@" > /run/tliset/log 2>&1
fi
date '+%Y-%m-%d_%H:%M:%S'
set -x
'
    fi
    script+="\
set -u

mkdir -p ${gen_mkdir_list[*]}
"
    if [[ ${#gen_body[@]} -ne 0 ]]; then
	local gen_body_txt
	printf -v gen_body_txt '%s\n' "${gen_body[@]}"
	script+="$gen_body_txt"
    fi

    local dir="/etc/systemd/system-generators"
    if under_qubes; then
	dir="/usr/local/etc"
    fi

    ensure_dir -p "$dir"
    write_file -m 755 "$dir/tliset" "$script"
    if let file_update; then
	if under_qubes; then
	    "$dir/tliset"
	fi
	cmd_log systemctl daemon-reload
    fi
}

p_add_raw() {
    gen_body+=("$1")
}

p_nl() {
    p_add_raw ''
}

# The first argument is <kind>:<subpath> where kind specifies
# directory kind and subpath is a file path. The second argument is
# text that should be written into the file at that path. Option -x
# indicattes that file must be executable.
p_file() {
    local -i executable=0
    if [[ "$1" == "-x" ]]; then
	shift
	executable=1
    fi
    local file_kind_and_path="$1"
    local body="$2"
    convert_shell_kind_path "$file_kind_and_path"
    local escaped_path="$R"
    escape_for_shell "$body"
    p_add_raw "> $escaped_path printf %s $R"
    if let executable; then
	p_add_raw "chmod 755 $escaped_path"
    fi
}

p_dir() {
    local dir="$1"
    convert_shell_kind_path "$dir"
    gen_mkdir_list+=("$R")
}

p_cmd() {
    local s="" arg
    for arg in "$@"; do
	if [[ $arg == *:* ]]; then
	    convert_shell_kind_path "$arg"
	else
	    escape_for_shell "$arg"
	fi
	s+="${s:+ }$R"
    done
    p_add_raw "$s"
}

convert_shell_kind_path() {
    local file_kind_and_path="$1"
    local file_kind="${file_kind_and_path%%:*}"
    [[ $file_kind != $file_kind_and_path ]] || err "the argument must start with <kind>: prefix"
    local file_path="${file_kind_and_path#*:}"
    local dir absolute=0
    case "$file_kind" in
	service ) dir='/run/systemd/system' ;;
	net ) dir='/run/systemd/network' ;;
	config ) dir="$gen_config" ;;
	mount ) dir="$gen_mount" ;;
	scripts ) dir="$gen_scripts" ;;
	top ) dir="" ; absolute=1 ;;
	* ) err "Unknown dir_kind $dir_kind" ;;
    esac
    if let absolute; then
	[[ $file_path =~ ^/. ]] || err "$file_kind must come with absolute path: $file_kind_and_path"
    else
	if [[ $file_path == '' ]]; then
	    R="$dir"
	    return 0
	fi
	[[ $file_path =~ ^[^/] ]] || \
	    err "$file_kind must come with relative path: $file_kind_and_path"
	dir+="/"
    fi
    escape_for_shell "$file_path"
    R="$dir$R"
}

p_mask_service() {
    p_cmd ln -s /dev/null "service:$1"
}

setup_kernel_parameters() {
    if let with_zswap; then
	p_add_raw 'printf 1 > /sys/module/zswap/parameters/enabled || :'
    fi
    setup_zram
}

setup_zram() {
    [[ $zram_size ]] || return 0

    log "Checking zram"

    p_nl
    p_file top:/run/tliset/zram-enable.sh '
set -e -u

SWAP_SIZE='"$zram_size"'

num_cpus=$(grep -c processor /proc/cpuinfo)
if [[ 0 = "$num_cpus" ]]; then
    num_cpus=1
fi

rm -f /run/tliset/zram-device
device="$(zramctl --find --size "$SWAP_SIZE" -t "$num_cpus")"
printf "%s\\n" "$device" > /run/tliset/zram-device

/sbin/mkswap "$device"
/sbin/swapon -p 100 "$device"
'

    p_nl
    p_file top:/run/tliset/zram-disable.sh "$(cat <<'EOF'
#!/bin/sh
set -e -u

device=
[[ -f /run/tliset/zram-device ]] || exit 0
read -r device < /run/tliset/zram-device || :
[[ $device ]] || exit 0
if grep -q "^$device\\s" /proc/swaps; then
    /sbin/swapoff "$device"
fi
zramctl --reset "$device"
rm /run/tliset/zram-device
EOF
)"

    p_nl
    p_file service:tliset-zram.service "\
[Unit]
Description=Service enabling RAM compression using zRam

[Install]
WantedBy=multi-user.target

[Service]
Type=oneshot
ExecStart=/sbin/modprobe zram num_devices=1
ExecStart=/bin/bash /run/tliset/zram-enable.sh
ExecStop=/bin/bash /run/tliset/zram-disable.sh
RemainAfterExit=yes
"
    multi_user_wants+=(tliset-zram.service)

}


setup_network() {
    log "Checking network"
    inc_log_level

    if [[ ${#explicit_ipv6[@]} -ne 0 ]]; then
	let kind_coreos || err "unsupported configuration"
	local ipv6_address="${explicit_ipv6[0]}"
	local ipv6_gateway="${explicit_ipv6[1]}"
	p_file net:zz-default.network "\
[Network]
DHCP=ipv4

Address=$ipv6_address
Gateway=$ipv6_gateway

[DHCP]
UseMTU=true
UseDomains=true
"
    fi

    dec_log_level
}

ensure_root_ssh_key() {
    local prefix=$1
    local file=/root/.ssh/$prefix-ed25519
    if [[ ! -s "$file" ]]; then
	cmd_log mkdir -p -m 0700 /root/.ssh
	cmd_log ssh-keygen -t ed25519 -N '' -f "$file"
    fi
    ssh_key_file="$file"
}

setup_hippyru_backup() {
    [[ $hippyru_backup_time ]] || return 0

    local ssh_key_file=
    ensure_root_ssh_key hippyru-www-backup

    if [[ $hippyru_backup_time == manual ]]; then
	return 0
    fi

    [[ $hippyru_backup_time =~ ^[0-2][0-9]:[0-5][0-9]:[0-5][0-9]$ ]] || \
	err "Invalid backup time spec in hippyru_backup_time - '$hippyru_backup_time'"

    p_file service:tliset-hippyru-backup.timer "\
[Unit]
After=network-online.target
Wants=network-online.target

[Timer]
Persistent=true
OnCalendar=$hippyru_backup_time
"
    p_file service:tliset-hippyru-backup.service "\
[Unit]
After=network-online.target
Wants=network-online.target

[Service]
ExecStart=/bin/bash $gen_scripts/hippyru-backup.bash
StandardError=journal
StandardOutput=journal
Type=oneshot
"
    multi_user_wants+=("tliset-hippyru-backup.timer")

    # Script source with condition code
    local s='#!/usr/bin/bash
set -e -u -o pipefail

# Number of days to keep old backups in the changed dir
max_keep_changed_days=60

'
    # On fedora change SELinux context for rsync so it is treated as
    # a binary. As an update can reset it, do it each time before running
    # rsync.
    if let kind_fedora; then
	s+='
se_context=$(stat -c %C /usr/bin/rsync)
if [[ $se_context =~ ^[^:]*:[^:]*:([^:]*):[^:]*$ ]]; then
    if [[ ${BASH_REMATCH[1]} != bin_t ]]; then
        echo "Changing SE context for /usr/bin/rsync from ${BASH_REMATCH[1]} to bin_t" 1>&2
        chcon -t bin_t /usr/bin/rsync
    fi
fi
'
    fi
    s+='

readonly backup_root="/area/backup"

remove_list=()

backup_from_host() {
    local pod_name="$1" host_name="$2"
    local data="$backup_root/$pod_name"
    local changes="$backup_root/changes/$pod_name"
    local partial="$backup_root/rsync-partial/$pod_name"
    local dir
    for dir in "$data" "$changes" "$partial"; do
        if [[ ! -d "$dir" ]]; then
            mkdir -p "$dir"
        fi
    done

    local -a ssh_cmd=(
        ssh -l backup -p 2022 -i ~/.ssh/hippyru-www-backup-ed25519
        -o Ciphers=aes128-gcm@openssh.com
        -o StrictHostKeyChecking=no
    )

    local -a rsync_args=(
        -rlpt
        --no-owner --no-group --omit-dir-times --omit-link-times
        --partial-dir="$partial" --delete-after
        --info=NAME
        --rsh="${ssh_cmd[*]}"
    )

    local too_old_backup="$changes/$(date --date="-20 days" +%Y-%m-%d)"
    rm -rf "$too_old_backup"
    local changed_files
    changed_files="$changes/$(date +%Y-%m-%d)"
    echo "Backing up $pod_name" >&2
    local ok=1
    rsync "${rsync_args[@]}" --backup --backup-dir="$changed_files" \
        "rsync://$host_name/srv/" "$data/srv/" || ok=
    if [[ $ok ]]; then
	local i cur_time
	cur_time="$(date +%s)"
	for i in "$changes"/20[0-9][0-9]-[0-9][0-9]-[0-9][0-9]; do
	    dir_time="$(date --date="${i##*/}" +%s)"
	    if test "$((cur_time-dir_time))" -gt "$((max_keep_changed_days*86400))"; then
		remove_list+=("$i")
	    fi
	done
    fi

}

backup_from_host bergenrabbit bergenrabbit.net

if [[ ${#remove_list[@]} -ne 0 ]]; then
    printf -v s "\\n\\t%s" "${remove_list[@]}"
    echo "removing older changes created more than $max_keep_changed_days days ago:$s"
    rm -rf "${remove_list[@]}"
fi

'

    p_file scripts:hippyru-backup.bash "$s"

    if let kind_fedora; then
	setsebool rsync_client 1
    fi
}

setup_services() {
    log "Checking services"
    inc_log_level

    setup_hippyru_backup

    if let with_docker; then
	# Make sure that docker starts. On CoreOS docker is
	# socket-activated by default which breaks restarting
	# containers on boot unless a docker client runs
	if ! under_qubes; then
	    multi_user_wants+=(docker.service)
	fi

	local docker_lib_dir=
	if under_qubes; then
	    docker_lib_dir=/rw/varlib/docker
	fi
	local docker_service_lines=()
	if [[ $docker_lib_dir ]]; then
	    local unit
	    unit="$(systemd-escape -p "/var/lib/docker").mount"
	    p_nl
	    p_file "service:$unit" "\
[Mount]
Where=/var/lib/docker
Type=none
Options=bind
What=$docker_lib_dir
"
	    docker_service_lines+=(
		"[Unit]"
		"BindsTo=$unit"
		"After=$unit"
	    )
	fi

	if let kind_fedora; then
	    p_mask_service docker-storage-setup.service
	    local exec_start=(
		/usr/bin/dockerd-current
		--add-runtime oci=/usr/libexec/docker/docker-runc-current
		--default-runtime=oci
		--containerd /run/containerd.sock
		--exec-opt native.cgroupdriver=systemd
		--userland-proxy=false
		--log-driver=journald
		--storage-driver=overlay2
	    )
	    docker_service_lines+=(
		"[Service]"
		"ExecStart="
		"ExecStart=${exec_start[*]}"
	    )
	fi

	if [[ $NAME == r2 ]]; then
	    docker_service_lines+=(
		"[Service]"
		"Environment=DOCKER_OPTS=--userland-proxy=false"
	    )

	fi

	if [[ ${#docker_service_lines[@]} -ne 0 ]]; then
	    p_dir service:docker.service.d
	    local text
	    printf -v text '%s\n' "${docker_service_lines[@]}"
	    p_file service:docker.service.d/tliset.conf "$text"
	fi
    fi

    dec_log_level
}

setup_files() {
    if let kind_coreos; then
	case $NAME in
	bergenrabbit  )
	    ensure_dir -m 0750 -g core /vol
	    ensure_dir -m 0750 -g core /vol/bergenrabbit
	    ensure_dir /vol/bergenrabbit/data

	    ensure_dir /opt /opt/dpodctl "/opt/dpodctl/$NAME"
	    write_file "/opt/dpodctl/$NAME/config.dpod" "\
ImageName $NAME
UseHostNetwork
"
	    ;;
	r2 )
	    ensure_dir /opt /opt/dpodctl "/opt/dpodctl/transdock"
	    write_file "/opt/dpodctl/transdock/config.dpod" "\
ImageName local/transdock
HostEnv TLS_HOSTS media.mir2.org
HostEnv ACME_CONTACT mailto:igor@mir2.org
UseHostNetwork
"
	    ;;
	thip )
	    ensure_dir -m 0750 -g core /vol
	    ensure_dir -m 0750 -g core /vol/bergenrabbit
	    ensure_dir /vol/bergenrabbit/data

	    ensure_dir -m 0775 -g "$primary_group" /vol/projects
	    ;;
	esac
    fi
    if [[ $NAME == rhea ]]; then
	ensure_dir /vol
	ensure_dir -u "$primary_user" -g "$primary_group" /vol/projects
    fi
}

setup_accounts() {
    if let with_sudoless_docker; then
	local s
	s="$(getent group docker 2>/dev/null || :)"
	if [[ ! $s  ]]; then
	    cmd_log groupadd docker
	fi
	if ! [[ $s =~ ^[^:]+:[^:]*:[^:]+:(.*,)?"$primary_user"(,|$) ]]; then
	    cmd_log usermod -aG docker "$primary_user"
	fi
    fi
}

setup_docker_services() {
    let with_docker || return 0

    if ! docker version -f '{{.Server.Version}}' > /dev/null 2>&1; then
	log "Attempting to start the docker daemon"
	cmd_log systemctl start docker
    fi

    if let with_docker_development_net; then
	local net_name="development"
	local subnet_template
	subnet_template='{{range .IPAM.Config}}{{if .Subnet}}{{.Subnet}}{{end}}{{end}}'
	local subnet="$dev_docker_network_prefix.0/24"
	local actual_subnet=
	docker network inspect -f "$subnet_template" "$net_name" 2> /dev/null \
	    | read -r actual_subnet || :
	if [[ $actual_subnet != "$subnet" ]]; then
	    log "Creating docker subnet $subnet"
	    if [[ $actual_subnet ]]; then
		cmd_log docker network rm "$net_name" > /dev/null
	    fi
	    cmd_log docker network create --subnet="$subnet" "$net_name" > /dev/null
	fi

	local extra_etc_hosts=()
	if [[ $NAME == thip ]]; then
	    setup_development_dpodctl
	fi

	local http_proxy_port=8080
	local container=http-proxy
	local dockerfile
	IFS= read -r -d '' dockerfile <<EOF || :
FROM alpine:latest
RUN apk update && apk add tinyproxy && rm -rf /var/cache/apk/*
RUN sed -i \
    -e 's|^Allow |# &|' \
    -e 's|#LogFile .*|LogFile "/dev/stderr"|' \
    -e 's|^Port .*|Port $http_proxy_port|' \
    -e 's|^ConnectPort .*|# &|' \
    /etc/tinyproxy/tinyproxy.conf
USER tinyproxy
CMD ["/usr/sbin/tinyproxy", "-d"]
EOF
	local docker_args=(
	    --restart=unless-stopped
	    --net development
	    -p "$http_proxy_port:$http_proxy_port"
	    --cap-drop ALL
	)
	local i
	for ((i=0; i<${#extra_etc_hosts[@]}; i+=2)); do
	    local ip="${extra_etc_hosts[i]}"
	    local hostname="${extra_etc_hosts[i+1]}"
	    docker_args+=(--add-host "$hostname:$ip")
	done
	docker_args+=("local/$container")

	local tag
	declare -p dockerfile docker_args | sha256sum | read -r tag _

	local status= current_tag=
	docker inspect --type container \
	    -f  '{{.State.Running}} {{index .Config.Labels "local.tag"}}' \
	    "$container" 2>/dev/null | read -r status current_tag || :
	if [[ $status != true || $current_tag != "$tag" ]]; then
	    log "Starting $container container"
	    if [[ $status == true ]]; then
		cmd_log docker stop "$container" > /dev/null
	    fi
	    if [[ $status ]]; then
		cmd_log docker rm -v "$container" > /dev/null
	    fi
	    printf %s "$dockerfile" | cmd_log docker build -t "local/$container" -
	    cmd_log docker run -d --name "$container" --label local.tag="$tag" \
		    "${docker_args[@]}" > /dev/null
	fi
    fi
}

setup_development_dpodctl() {
    local net_name="development"

    local dir="/opt/dpodctl"
    ensure_dir /opt/dpodctl

    local projects_root="/vol/projects"

    local i ip4_last_byte=10
    for i in bergenrabbit transdock; do
	local -a dns_aliases=()
	ensure_dir "$dir/$i"
	local ipv4="$dev_docker_network_prefix.$ip4_last_byte"
	: $((ip4_last_byte+=1))
	case $i in
	transdock )
	    dns_aliases=(media.mir2.org test.media.mir2.org)
	    write_file "$dir/$i/config.dpod" "\
IncludeBuild $projects_root/$i/config.dpod
DnsAlias media.mir2.org
DnsAlias test.media.mir2.org
HostEnv ACMELOOP_HOST 'media.mir2.org test.media.mir2.org'
HostEnv ACMELOOP_CA http://boulder:4000/directory
HostEnv ACMELOOP_CONTACT mailto:igor@mir2.org

HostEnv TLS_HOSTS 'media.mir2.org test.media.mir2.org'
HostEnv ACME_CA http://boulder:4000/directory
HostEnv ACME_CONTACT mailto:igor@mir2.org
BindAddress none
Network $net_name
NetworkIPv4 $ipv4
"
	    ;;
	bergenrabbit )
	    dns_aliases=(
		www.bergenrabbit.net bergenrabbit.net
		www.bergenrabbit.no bergenrabbit.no

		www.hippyru.net hippyru.net lib.hippyru.net
		www.hippy.ru hippy.ru

		www.lubava.info lubava.info
	    )
	    local config="\
development_mode
docker_arg --net=$net_name
docker_arg --ip=$ipv4
"
	    local dns_alias
	    for dns_alias in "${dns_aliases[@]:+${dns_aliases[@]}}"; do
		config+="docker_arg --net-alias=$dns_alias$NL"
	    done
	    write_file "/vol/$i.conf" "$config"
	    ;;
	esac

	local dns_alias
	for dns_alias in "${dns_aliases[@]:+${dns_aliases[@]}}"; do
	    extra_etc_hosts+=("$ipv4" "$dns_alias")
	done
    done
}

show_usage=""
NAME=""
remote=""

while getopts :hn:r:u: opt; do
    case "$opt" in
	h ) show_usage=1 ;;
	n )
	    NAME="$OPTARG"
	    is_valid_host_name "$NAME" || \
		usage_err "The value of -n argument '$NAME' is not a known host name."
	    ;;
	r )
	    remote="$OPTARG"
	    is_valid_host_name "$remote" || \
		usage_err "The value of -r argument '$remote' is not a known host name."
	    ;;
	* ) getopts_err "$opt" "${OPTARG-}";;
    esac
done

#[[ $# -eq $(($OPTIND - 1)) ]] || usage_err "Unexpected extra arguments: $@"
let OPTIND==1+$# || usage_err "Unexpected extra arguments: $@"

[[ -z "$remote" || -z "$NAME" ]] || usage_err "Only one of -n, -r can be given"

if [[ -n "$show_usage" ]]; then
    echo "Usage: $0 [OPTION]..."
    echo "Customize installation for the given computer."
    echo
    echo "  -h  show this help and exit"
    echo "  -n name  assume the given name as the hostname rather than use /etc/hostname."
    echo "           The valid values are (${valid_host_names[*]})."
    echo "  -r name  execute setup on the remote machine name using ssh to copy the setup files."
    echo
    exit
fi

if [[ $remote ]]; then
    NAME=$remote
elif [[ -z "$NAME" ]]; then
    read_tliset_name
    NAME="$R"
fi

get_host_options

if [[ -n "$remote" ]]; then
    cmd=(run_remotely)
    if [[ -n "$ssh_login_user" ]]; then
	# Use sudo
	cmd+=(-s "$ssh_login_user@$remote")
    else
	cmd+=("root@$remote")
    fi
    "${cmd[@]}" -n "$remote"
fi

if [[ "$(id -u)" -ne 0 ]]; then
    exec sudo env SUDO_USER="$(id -un)" "$0" "$@"
fi

determine_os

if [[ $SUDO_USER ]]; then
    primary_user="$SUDO_USER"
    primary_group="$(id -gn "$SUDO_USER")"
else
    [[ $primary_user && $primary_group ]] || \
	err "primary_user and primary_group must be set when not using sudo"
fi

if let kind_fedora; then
    fedora_release="$(rpm -E %fedora)"
fi

if ! under_qubes; then
    setup_packages
fi

start_generator_write

setup_kernel_parameters
setup_network
setup_services
setup_files
setup_accounts

finish_generator_write

# Run services after the docker is configured
setup_docker_services

log "Done."
