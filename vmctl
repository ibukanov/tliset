#!/bin/sh

set -e -u
#set -x

umask 002

log() {
    printf '%s\n' "$*" >&2
}

err() {
    log "$@"
    exit 1
}

cmd_log() {
    log "$@"
    "$@"
}

get_config() {
    VM="$1"
    readonly VM

    coreos=
    debian=
    centos=
    use_ssh_login_key=
    data_vol_size=

    case "$VM" in
    thip )
        coreos=1
        vm_memory=2048M
        data_vol_size=145G
        ssh_host_port=2222
        test_br_ssh_port=2223

        ;;
    test-br )
        debian=1
        vm_memory=1024M
        ssh_host_port=15022
        use_ssh_login_key=1
        ;;
    centos )
        centos=1
        vm_memory=1024M
        ssh_host_port=15122
        use_ssh_login_key=1
        ;;

    * ) err "unknown VN name - '${VM}'" ;;
    esac

    readonly centos coreos debian
    readonly use_ssh_login_key
    readonly vm_memory
    readonly data_vol_size
    readonly ssh_host_port

    if test -n "${coreos}"; then
        readonly channel=beta
        readonly base_url="https://${channel}.release.core-os.net/amd64-usr/current"
        readonly key_uid='CoreOS Buildbot (Offical Builds) <buildbot@coreos.com>'
        readonly key_url="https://coreos.com/security/image-signing-key/CoreOS_Image_Signing_Key.pem"
        readonly prefix="coreos_production_qemu"
    fi

    readonly user_unit_dir="${XDG_RUNTIME_DIR}/systemd/user"
    readonly user_unit="${VM}.service"
    readonly user_unit_path="${user_unit_dir}/${user_unit}"

    if test -n "${coreos}"; then
        readonly dir=/vol/vm/coreos
        readonly ssh_user=core
    elif test -n "${debian}"; then
        readonly dir=/vol/vm/debian
        readonly ssh_user=root
    elif test -n "${centos}"; then
        readonly dir=/vol/vm/centos
        readonly ssh_user=root
    fi

    readonly rundir="${XDG_RUNTIME_DIR}/vm/${VM}"

    main_vol="${VM}-main.img"
    data_vol="${VM}-data.img"
    if test -n "${debian}"; then
        main_vol="${VM}-main.qcow2"
    fi

    readonly main_vol data_vol

    if test -n "${use_ssh_login_key}"; then
        export SSH_AUTH_SOCK="${XDG_RUNTIME_DIR}/ssh-agent.socket"
    else
        export SSH_AUTH_SOCK="${XDG_RUNTIME_DIR}/ssh-agent-$VM.socket"
    fi
}

is_vm() {
    local name
    name="$1"
    test "x${name}" = "x${VM}"
}

# Set R to concatenation of arguments with spaces escaped if necessary.
escape_for_shell() {
    R=
    local arg
    for arg in "$@"; do
        case "${arg}" in
        "" | *[!A-Z0-9a-z_./-]* )
            local escaped before_quote
            escaped=
            while : ; do
                before_quote="${arg%%\'*}"
                if test "x${arg}" = "x${before_quote}"; then
                    break
                fi
                escaped="${escaped}${before_quote}'\\''"
                arg="${arg#*\'}"
            done
            arg="'$escaped$arg'"
            ;;
        esac
        R="${R}${R:+ }${arg}"
    done
}

earg() {
    escape_for_shell "$@"
    eargs="${eargs}${eargs:+ }$R"
}

fetch_as_tmp_file() {
    local file
    file="$1"
    curl -o "${file}.tmp" "${base_url}/${file}"
}

check_gpg_signature() {
    local path="$1" sig="$2"
    local gpg_output
    log "Checking ${path} signature"
    gpg_output="$(gpg --batch --verify "${sig}" "${path}" 2>&1 || true)"
    if ! printf '%s\n' "${gpg_output}" | grep -q "^gpg: Good signature from "; then
        err "${gpg_output}"
    fi
}

setup_vm_images() {
    if ! test -d "${dir}"; then
        mkdir -p "${dir}"
    fi

    if test -n "${centos}"; then
        setup_centos_images
    fi
    if test -n "${coreos}"; then
        setup_coreos_images
    fi
    if test -n "${debian}"; then
        setup_debian_images
    fi
}

setup_centos_images() {
    if ! test -e "${dir}/${main_vol}"; then
        log "Creating new Centos installation"
        local install_iso
        install_iso=CentOS-7-x86_64-Minimal-1708.iso
        if ! test -e "${dir}/${install_iso}"; then
            err "The source image for installation does not exist - ${dir}/${install_iso}"
        fi
        local ssh_pubkey_path
        ssh_pubkey_path="$HOME/.local/hsetup/vm/${VM}_ssh_login_key.pub"
        local ssh_pubkey
        if ! IFS= read -r ssh_pubkey < "${ssh_pubkey_path}" || test -z "${ssh_pubkey}"; then
            err "${ssh_pubkey_path} does not exist or is not properly formated, initialize it with public key to login"
        fi

        local install_tmp
        install_tmp="${dir}/install.tmp"
        rm -rf "${install_tmp}"
        mkdir "${install_tmp}"

        qemu-img create -f qcow2 "${install_tmp}/${main_vol}" 15G > /dev/null

        local kickstart='

# Install using cdrom
install
cdrom

# non-interactive setup
cmdline

# System language
lang en_US.UTF-8

# Keyboard layouts
keyboard us

# Enable more hardware support
# unsupported_hardware

# Network information
network --activate --device eth0 --bootproto=dhcp --hostname='"$VM"' --onboot=yes

# System authorization information
auth --enableshadow --passalgo=sha512

# Root password
rootpw test

# Selinux in permissive mode (will be disabled by provisioners)
#selinux --permissive

# System timezone
timezone UTC

# System bootloader configuration
bootloader --location=mbr --boot-drive=vda
#bootloader --append=" crashkernel=auto" --location=mbr --boot-drive=vda

# Skip X config
skipx

# Create fresh partition on /dev/vda
ignoredisk --only-use=vda
zerombr
clearpart --all --drives=vda

# Disk partitioning information
part /boot --asprimary --fstype="ext4" --ondisk=vda --size=512 --label=BOOT
part / --asprimary --fstype="ext4" --ondisk=vda --size=512 --grow --label=ROOT


# Do not run the Setup Agent on first boot
firstboot --disabled

# Accept the EULA
eula --agreed

# System services
services --disabled chronyd,NetworkManager,postfix --enabled sshd

poweroff


# Packages

%packages --ignoremissing --excludedocs
@^minimal
@core
kexec-tools
rsync
# unnecessary firmware
-aic94xx-firmware
-atmel-firmware
-b43-openfwwf
-bfa-firmware
-ipw2100-firmware
-ipw2200-firmware
-ivtv-firmware
-iwl100-firmware
-iwl1000-firmware
-iwl3945-firmware
-iwl4965-firmware
-iwl5000-firmware
-iwl5150-firmware
-iwl6000-firmware
-iwl6000g2a-firmware
-iwl6050-firmware
-libertas-usb8388-firmware
-ql2100-firmware
-ql2200-firmware
-ql23xx-firmware
-ql2400-firmware
-ql2500-firmware
-rt61pci-firmware
-rt73usb-firmware
-xorg-x11-drv-ati-firmware
-zd1211-firmware

%end

#%addon com_redhat_kdump --enable --reserve-mb='"'auto'"'

#%end

%post

sed -i -e "s/^GRUB_TIMEOUT=.*/GRUB_TIMEOUT=1/" /etc/default/grub
grub2-mkconfig > /boot/grub2/grub.cfg
echo "blacklist floppy" > /etc/modprobe.d/blacklist-floppy.conf

sed -i \
    -e "s/^#?PermitRootLogin .*/PermitRootLogin prohibit-password/" \
    -e "s/^AcceptEnv .*/#&/g" \
    /etc/ssh/sshd_config
mkdir -p /root/.ssh
chmod 700 /root/.ssh
printf "%s\\n" '"'${ssh_pubkey}'"' > /root/.ssh/authorized_keys
chmod 600 /root/.ssh/authorized_keys

systemctl disable firewalld
%end
'
        dd if=/dev/zero "of=${install_tmp}/kickstart.img" status=none bs=512K count=1
        mkfs.vfat "${install_tmp}/kickstart.img" > /dev/null
        printf %s "${kickstart}" | mcopy -i "${install_tmp}/kickstart.img" - ::ks.cfg

        cmd_log isoinfo -i "${dir}/${install_iso}" -x /isolinux/initrd.img -R \
            > "${install_tmp}/initrd.img"
        isoinfo -i "${dir}/${install_iso}" -x /isolinux/vmlinuz -R \
            > "${install_tmp}/vmlinuz"

        local eargs
        eargs=

        earg -name "${VM}" -machine accel=kvm
        earg -m "${vm_memory}" -cpu host -smp 2

        earg -net nic,vlan=0,model=virtio
        earg -net "user,vlan=0,hostname=${VM}"

        earg -drive if=virtio,index=0,file="${install_tmp}/${main_vol},format=qcow2"
        earg -drive if=virtio,index=1,file="${install_tmp}/kickstart.img,format=raw"

        earg -cdrom "${dir}/${install_iso}"

        earg -nographic

        #earg -boot d
        earg -kernel "${install_tmp}/vmlinuz"
        earg -initrd "${install_tmp}/initrd.img"

        local kernel_args
        kernel_cmdline='inst.stage2=hd:LABEL=CentOS\x207\x20x86_64'
        kernel_cmdline="${kernel_cmdline} ks=hd:vdb:/ks.cfg"
        kernel_cmdline="${kernel_cmdline} vga=off console=ttyS0,115200n8"
        earg -append "${kernel_cmdline}"

        eval "qemu-system-x86_64 ${eargs}"

        mv "${install_tmp}/${main_vol}" "${dir}/${main_vol}"
        rm -rf "${install_tmp}"
    fi
}

setup_coreos_images() {

    cd "$dir"

    if ! test -f "${prefix}_image.img.bz2"; then
        if ! gpg -k "${key_uid}" > /dev/null 2>&1; then
            log "Importing CoreOS key"
            curl "${key_url}" | gpg --import -
        fi
        fetch_as_tmp_file "${prefix}_image.img.bz2"
        fetch_as_tmp_file "${prefix}_image.img.bz2.sig"
        check_gpg_signature "${prefix}_image.img.bz2.tmp" "${prefix}_image.img.bz2.sig.tmp"
        mv "${prefix}_image.img.bz2.tmp" "${prefix}_image.img.bz2"
        rm "${prefix}_image.img.bz2.sig.tmp"
    fi

    if ! test -f "${main_vol}"; then
        log "Decompressing downloaded coreos image"
        bzip2 -d "${prefix}_image.img.bz2" -c > "${main_vol}.tmp"
        mv "${main_vol}.tmp" "${main_vol}"
    fi

    if test -n "${data_vol_size}" -a ! -f "${data_vol}"; then
        log "Allocating ${data_vol} - ${data_vol_size}"

        # write zeros at the start to facilitate detection of filesystem absence
        dd if=/dev/zero "of=${data_vol}.tmp" bs=64K count=1 status=none
        fallocate -l "${data_vol_size}" "${data_vol}.tmp"
        chmod 640 "${data_vol}.tmp"
        mv "${data_vol}.tmp" "${data_vol}"
    fi
}

setup_debian_images() {
    local initial_vol
    initial_vol="${main_vol%.qcow2}-initial.qcow2"

    if ! test -f "${dir}/${initial_vol}.gz"; then
        log "Downloading Debian installer"
        rm -rf "${dir}/${VM}.tmp"
        mkdir "${dir}/${VM}.tmp"
        cd "${dir}/${VM}.tmp"

        local mirror_host mirror_top_dir mirror_path
        mirror_host=cdn-fastly.deb.debian.org
        mirror_top_dir=debian
        mirror_path=dists/stretch/main/installer-amd64/current/images
        curl -O "http://${mirror_host}/${mirror_top_dir}/${mirror_path}/netboot/netboot.tar.gz"

        # Download checksum from another host using https
        curl -O "https://cdn-aws.deb.debian.org/debian/${mirror_path}/SHA256SUMS"

        log "Checking installer checksum"
        local s
        s="$(egrep '^[0-9a-f]+  \./netboot/netboot\.tar\.gz$' SHA256SUMS || :)"
        if test -z "${s}"; then
            err "SHA256SUMS does not contain netboot/netboot.tar.gz entry"
        fi
        printf '%s\n' "${s%% *}  ./netboot.tar.gz" > SHA256SUMS.tmp
        sha256sum -c SHA256SUMS.tmp

        log "Generating preseeded initrd"

        local end_install_script
        end_install_script='
mkdir -p -m 0700 /root/.ssh
ln -s /run/ssh_authorized/root /root/.ssh/authorized_keys

printf %s "\
[Mount]
Where=/run/ssh_authorized
What=ssh_authorized
Type=9p
Options=ro,access=client,trans=virtio
" > /etc/systemd/system/run-ssh_authorized.mount

mkdir -p /etc/systemd/system/local-fs.target.wants
ln -s /etc/systemd/system/run-ssh_authorized.mount /etc/systemd/system/local-fs.target.wants

touch /.initialized
'
        end_install_script="$(printf %s "${end_install_script}" | gzip -9 | base64 -w0)"

        local preseed
        preseed="\
#_preseed_V1
d-i debian-installer/locale string en_US
d-i keyboard-configuration/xkb-keymap select us

d-i netcfg/choose_interface select auto
# d-i netcfg/choose_interface select eth1

d-i netcfg/get_hostname string unassigned-hostname
d-i netcfg/get_domain string unassigned-domain
d-i netcfg/hostname string ${VM}
d-i netcfg/domain string

d-i mirror/country string manual
d-i mirror/http/hostname string ${mirror_host}
d-i mirror/http/directory string /${mirror_top_dir}
d-i mirror/http/proxy string

d-i passwd/make-user boolean false
d-i passwd/root-password password root
d-i passwd/root-password-again password root

d-i clock-setup/utc boolean true
d-i time/zone string Etc/UTC
d-i clock-setup/ntp boolean false

d-i partman-auto/disk string /dev/vda
d-i partman-auto/method string regular
d-i partman-lvm/device_remove_lvm boolean true
d-i partman-md/device_remove_md boolean true
d-i partman-auto/choose_recipe select atomic

d-i partman-md/confirm boolean true
d-i partman-partitioning/confirm_write_new_label boolean true
d-i partman/choose_partition select finish
d-i partman/confirm boolean true
d-i partman/confirm_nooverwrite boolean true

d-i partman/mount_style select uuid

d-i apt-setup/non-free boolean false
d-i apt-setup/contrib boolean false
d-i apt-setup/services-select multiselect security, updates
d-i apt-setup/local0/source boolean true

tasksel tasksel/first multiselect standard
d-i pkgsel/include string openssh-server
popularity-contest popularity-contest/participate boolean false

d-i grub-installer/only_debian boolean true
d-i grub-installer/with_other_os boolean true
d-i grub-installer/bootdev  string /dev/vda
d-i debian-installer/add-kernel-opts string vga=off console=ttyS0,115200n8

d-i finish-install/reboot_in_progress note
d-i debian-installer/exit/poweroff boolean true

d-i preseed/late_command string in-target /bin/sh -c 'printf %s ${end_install_script} | base64 -d | gunzip | sh'
"

        tar -xzf netboot.tar.gz --strip-components=3 \
            ./debian-installer/amd64/linux ./debian-installer/amd64/initrd.gz
        gzip -d initrd.gz
        printf %s "${preseed}" > preseed.cfg
        printf '%s\n' preseed.cfg | cpio -H newc -o -A -F initrd
        #gzip initrd

        log "Creating new qcow2 volume"
        qemu-img create -f qcow2 "${initial_vol}" 6G

        log "Running the installer"
        local eargs
        eargs=
        earg -net user -net nic,model=virtio -m 2G
        earg -drive if=virtio,index=0,format=qcow2,file="${initial_vol}"
        earg -kernel linux -initrd initrd
        earg -nographic -append 'DEBIAN_FRONTEND=text vga=off console=ttyS0,115200n8 --- quiet'

        eval "qemu-system-x86_64 ${eargs}"

        mkdir root_fs
        guestmount -a "${initial_vol}" -m /dev/sda1 root_fs
        if ! test -f root_fs/.initialized ; then
            fusermount -uz root_fs
            err "Failed to find .initialized marker in the root filesystem"
        fi
        fusermount -uz root_fs

        log "Compressing the volume with the new installation"
        gzip -9 "${initial_vol}"
        mv "${initial_vol}.gz" "${dir}/${initial_vol}.gz"

        cd "${dir}"

        rm -rf "${dir}/${VM}.tmp"
    fi

    exit 1

    if ! test -f "${dir}/${main_vol}"; then
        log "Creating new main volume from the compressed initial one"
        gunzip -k "${dir}/${initial_vol}.gz"
        qemu-img amend -p -o preallocation=falloc "${dir}/${initial_vol}"


        mv "${dir}/${initial_vol}" "${dir}/${main_vol}"
    fi

}

setup_vm_config() {
    rm -rf "${rundir}"

    mkdir -p -m 700 "${rundir}"

    local ssh_config
    ssh_config="\
HostKeyAlias $VM
HostName 127.0.0.1
CheckHostIP no
Port ${ssh_host_port}
User ${ssh_user}
Ciphers aes128-gcm@openssh.com
UserKnownHostsFile ${rundir}/ssh.known_hosts
IdentityAgent ${SSH_AUTH_SOCK}
"

    if test -n "${use_ssh_login_key}"; then
        local real_key
        real_key="$(realpath "${HOME}/.local/hsetup/vm/${VM}_ssh_login_key")"
        ssh_config="${ssh_config}\
IdentitiesOnly yes
IdentityFile ${real_key}
ForwardAgent no
"
    else
        ssh_config="${ssh_config}\
IdentitiesOnly no
IdentityFile none
ForwardAgent yes
"
    fi

    printf %s "${ssh_config}" > "${rundir}/ssh.conf"

    chmod 600 "${rundir}/ssh.conf"

    if test -n "${coreos}"; then
        mkdir -p "${rundir}/configdrive/openstack/latest"

        local ssh_keys_yaml
        ssh_keys_yaml="$(ssh-add -L | sed -e 's/^/  - /' || :)"
        test -n "${ssh_keys_yaml}" || err "ssh agent at ${SSH_AUTH_SOCK} has no identities"

        printf %s '#cloud-config
hostname: "'"${VM}"'"
ssh_authorized_keys:
'"${ssh_keys_yaml}"'
' > "${rundir}/configdrive/openstack/latest/user_data"
    fi
}

start_vm() {
    local net_opt
    net_opt="user,vlan=0,hostname=$VM"
    net_opt="${net_opt},net=10.0.2.0/24,host=10.0.2.2,dns=10.0.2.3"
    net_opt="${net_opt},hostfwd=tcp:127.0.0.1:${ssh_host_port}-:22"
    if is_vm thip; then
        net_opt="${net_opt},hostfwd=tcp:127.0.0.1:${test_br_ssh_port}-:2022"
    fi

    local eargs
    eargs=

    earg -name "${VM}"
    earg -machine accel=kvm
    earg -m "${vm_memory}"
    earg -cpu host
    earg -smp 2
    earg -nographic
    earg -qmp "unix:${rundir}/qmp-sock,server,nowait"
    earg -net nic,vlan=0,model=virtio,
    earg -net "${net_opt}"
    earg -drive if=virtio,index=0,file="${dir}/${main_vol}"
    if test -n "${data_vol_size}"; then
        earg -drive if=virtio,index=1,file="$dir/$data_vol",format=raw
    fi
    earg -fsdev local,id=conf,security_model=none,readonly,path="${rundir}/configdrive"
    earg -device virtio-9p-pci,fsdev=conf,mount_tag=config-2

    eval "cmd_log qemu-system-x86_64 ${eargs}" < /dev/null > "${rundir}/log" 2>&1 &
    local qemu_pid
    qemu_pid="$!"

    log "waiting for $VM to start sshd"
    local i
    i=0
    while : ; do
        sleep 0.2
        local eargs
        eargs=
        earg -o StrictHostKeyChecking=no
        earg -o ExitOnForwardFailure=yes
        earg -o ControlMaster=yes
        earg -f -N "${VM}"
        eval "ssh ${eargs}" && break
        kill -n 0 "${qemu_pid}" || err "unexpected qemu exit"
        : "$((i+=1))"
        if test 150 -le "$((i+=1))"; then
            log "failed to connect to ssh at ${VM}, shutting down"
            stop_vm "${qemu_pid}"
            exit 1
        fi
    done
    log "${VM} started and ssh is ready"
    echo "${qemu_pid}" > "${rundir}/pid"


    local lsyncd_config
    lsyncd_config="${self_dir}/lsyncd/${VM}.lsyncd"
    if test -f "${lsyncd_config}"; then
        # Use -nodaemon + & to disable logging to syslog
        /usr/bin/lsyncd -nodaemon "${lsyncd_config}" &
    fi

}

stop_vm() {
    local pid
    pid="$1"
    printf '{ "execute": "qmp_capabilities" }\n { "execute": "system_powerdown" }' \
        | nc -U "$rundir/qmp-sock"
    local i;
    i=0
    while :; do
        if test 100 -lt "$((i+=1))"; then
            echo "qemu has not performed a clean powerdown after 5 seconds" >&2
        fi
        sleep 0.05
        if ! kill -0 "${pid}" 2>/dev/null; then
            echo "qemu has performed clean powerdown" >&2
            break
        fi
    done
}

setup_and_run_vm() {
    local start_user_unit
    if ! test -f $user_unit_path; then
        start_user_unit=1
    elif ! systemctl --user is-active -q "${user_unit}"; then
        start_user_unit=1
        if systemctl --user is-failed -q "${user_unit}"; then
            systemctl -q --user reset-failed "${user_unit}"
        fi
    else
        start_user_unit=
    fi

    if test -n "${start_user_unit}"; then
        setup_vm_images
        setup_vm_config
        mkdir -p "${user_unit_dir}"
        printf %s '
[Service]
Environment=SSH_AUTH_SOCK='"${SSH_AUTH_SOCK}"'
Type=forking
ExecStart='"${self}"' internal start_vm '"${VM}"'
ExecStop='"${self}"' internal stop_vm '"${VM}"' $MAINPID
PIDFile='"${rundir}/pid"'
' > "${user_unit_path}"
        systemctl --user daemon-reload

        log "Starting ${VM} VM"
        systemctl --user start "${user_unit}"
    fi
}

self="$(realpath "$0")"
self_dir="${self%/*}"
readonly self self_dir

if test $# -eq 0; then
    set -- setup
fi

command="$1"
shift

if test internal = "${command}"; then
    internal_command="$1"
    get_config "$2"
    shift 2
    case "${internal_command}" in
    start_vm ) start_vm "$@" ;;
    stop_vm ) stop_vm "$@" ;;
    * ) err "unknown internal command - ${internal_command}" ;;
    esac
    exit 0
fi

get_config "${0##*/}"

case "${command}" in
setup ) setup_and_run_vm ;;
stop ) exec systemctl --user stop "${user_unit}" ;;
status ) exec systemctl --user status "${user_unit}" ;;
* ) err "unknown command - ${command}"
esac
